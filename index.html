<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"benzblog.site","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":{"enable":true,"replace_from":"(\\?x-oss-process=style\\S+)","replace_to":"","with_caption":false},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="奔哲明的博客">
<meta property="og:url" content="https://benzblog.site/index.html">
<meta property="og:site_name" content="奔哲明的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="BenZ">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://benzblog.site/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>奔哲明的博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-101354718-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-101354718-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?311511b30756494577b67a167866028f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="奔哲明的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">奔哲明的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://benzblog.site/2020-04-15-Kaldi%20%E8%AE%AD%E7%BB%83%E5%A3%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://benzgallery.oss-cn-shanghai.aliyuncs.com/sailing_cat 1200.png">
      <meta itemprop="name" content="BenZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔哲明的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020-04-15-Kaldi%20%E8%AE%AD%E7%BB%83%E5%A3%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Kaldi 训练声学模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-15T00:00:00+08:00">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-25 16:09:53" itemprop="dateModified" datetime="2020-04-25T16:09:53+08:00">2020-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020-04-15-Kaldi%20%E8%AE%AD%E7%BB%83%E5%A3%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020-04-15-Kaldi 训练声学模型/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            
            <div class="post-tags" style="margin:5px">
                <a href="/tags/ASR/" rel="tag"><i class="fa fa-tag"></i> ASR</a>
                <a href="/tags/kaldi/" rel="tag"><i class="fa fa-tag"></i> kaldi</a>
            </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>kaldi 是最为流行的语音识别开发工具，这次我们使用 kaldi 来进行一个唤醒词（keyword spotting）模型的训练。本篇主要涉及声学模型部分。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020-04-15-Kaldi%20%E8%AE%AD%E7%BB%83%E5%A3%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://benzblog.site/how_to_use_tf_serving_model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://benzgallery.oss-cn-shanghai.aliyuncs.com/sailing_cat 1200.png">
      <meta itemprop="name" content="BenZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔哲明的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/how_to_use_tf_serving_model/" class="post-title-link" itemprop="url">Tensorflow Serving 要点 </a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-27 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-27T00:00:00+08:00">2019-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-28 23:11:10" itemprop="dateModified" datetime="2019-11-28T23:11:10+08:00">2019-11-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/how_to_use_tf_serving_model/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="how_to_use_tf_serving_model/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            
            <div class="post-tags" style="margin:5px">
                <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 机器学习</a>
                <a href="/tags/Tensorflow/" rel="tag"><i class="fa fa-tag"></i> Tensorflow</a>
                <a href="/tags/tf-serving/" rel="tag"><i class="fa fa-tag"></i> tf-serving</a>
            </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Tensorflow serving 是用来帮助把模型部署到 Server 上的，模型格式为 SavedModel。 最近在使用 Tensorflow serving 时踩了一些坑，这里聊作记录，以供后来者参考</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/how_to_use_tf_serving_model/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://benzblog.site/training_a_face_segmentation_model_with_deeplab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://benzgallery.oss-cn-shanghai.aliyuncs.com/sailing_cat 1200.png">
      <meta itemprop="name" content="BenZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔哲明的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/training_a_face_segmentation_model_with_deeplab/" class="post-title-link" itemprop="url">使用 DeepLab 训练一个人脸语义分割模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-23 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:00+08:00">2019-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-27 00:13:18" itemprop="dateModified" datetime="2019-08-27T00:13:18+08:00">2019-08-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/training_a_face_segmentation_model_with_deeplab/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="training_a_face_segmentation_model_with_deeplab/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            
            <div class="post-tags" style="margin:5px">
                <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 深度学习</a>
                <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 机器学习</a>
                <a href="/tags/SemanticSegmentation/" rel="tag"><i class="fa fa-tag"></i> SemanticSegmentation</a>
                <a href="/tags/slim/" rel="tag"><i class="fa fa-tag"></i> slim</a>
            </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>DeepLab 是语义分割的STOA，我的项目需要把人脸抠图出来从而去除背景的干扰，适合使用语义分割的方法，由于用自己写的 unet 训练后效果很差，又自我感觉数据集没什么问题，因而决定用 DeepLab 再试试。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/training_a_face_segmentation_model_with_deeplab/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://benzblog.site/GMIS%202019%20%E7%B2%BE%E5%8D%8E%E6%A2%B3%E7%90%86%E5%8F%8A%E6%94%B6%E8%8E%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://benzgallery.oss-cn-shanghai.aliyuncs.com/sailing_cat 1200.png">
      <meta itemprop="name" content="BenZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔哲明的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GMIS%202019%20%E7%B2%BE%E5%8D%8E%E6%A2%B3%E7%90%86%E5%8F%8A%E6%94%B6%E8%8E%B7/" class="post-title-link" itemprop="url">GMIS 2019 精华梳理及收获</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-07-24 00:00:00 / 修改时间：21:01:03" itemprop="dateCreated datePublished" datetime="2019-07-24T00:00:00+08:00">2019-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/GMIS%202019%20%E7%B2%BE%E5%8D%8E%E6%A2%B3%E7%90%86%E5%8F%8A%E6%94%B6%E8%8E%B7/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="GMIS 2019 精华梳理及收获/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            
            <div class="post-tags" style="margin:5px">
                <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 机器学习</a>
                <a href="/tags/%E4%BC%9A%E8%AE%AE%E5%88%86%E4%BA%AB/" rel="tag"><i class="fa fa-tag"></i> 会议分享</a>
                <a href="/tags/AI/" rel="tag"><i class="fa fa-tag"></i> AI</a>
            </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>全球机器智能峰会 (Global Machine Intelligence Summit 简称 GMIS)  本次由机器之心和市北高新集团联合举办 https://gmis.jiqizhixin.com/  简单讲讲与会收获</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/GMIS%202019%20%E7%B2%BE%E5%8D%8E%E6%A2%B3%E7%90%86%E5%8F%8A%E6%94%B6%E8%8E%B7/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://benzblog.site/2019-07-12-HexoTricks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://benzgallery.oss-cn-shanghai.aliyuncs.com/sailing_cat 1200.png">
      <meta itemprop="name" content="BenZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔哲明的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-07-12-HexoTricks/" class="post-title-link" itemprop="url">本博客搭建总结的一些可供参考的技术要点 Hexo Next 修改</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-12T00:00:00+08:00">2019-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-29 21:49:08" itemprop="dateModified" datetime="2019-07-29T21:49:08+08:00">2019-07-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/skill/" itemprop="url" rel="index"><span itemprop="name">skill</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2019-07-12-HexoTricks/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019-07-12-HexoTricks/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            
            <div class="post-tags" style="margin:5px">
                <a href="/tags/skill/" rel="tag"><i class="fa fa-tag"></i> skill</a>
                <a href="/tags/web/" rel="tag"><i class="fa fa-tag"></i> web</a>
                <a href="/tags/js/" rel="tag"><i class="fa fa-tag"></i> js</a>
            </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>罗列下搭建本博客对原 hexo 以及 next 主题的一些细小改动。 这些改动主要是为了满足个人的一些功能需求，比如说，我需要点击图片能放大，我需要更符合 markdown 语法的注脚插件等等。其他人或许也有相似需求，简单讲下思路，没准能有启发作用</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019-07-12-HexoTricks/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://benzblog.site/2019-07-04-IconTransfer%20%E5%9B%BE%E6%A0%87%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://benzgallery.oss-cn-shanghai.aliyuncs.com/sailing_cat 1200.png">
      <meta itemprop="name" content="BenZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔哲明的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-07-04-IconTransfer%20%E5%9B%BE%E6%A0%87%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/" class="post-title-link" itemprop="url">IconTransfer 图标生成技术预研</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-04 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-04T00:00:00+08:00">2019-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-08 23:58:11" itemprop="dateModified" datetime="2019-07-08T23:58:11+08:00">2019-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2019-07-04-IconTransfer%20%E5%9B%BE%E6%A0%87%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019-07-04-IconTransfer 图标生成技术预研/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            
            <div class="post-tags" style="margin:5px">
                <a href="/tags/GAN/" rel="tag"><i class="fa fa-tag"></i> GAN</a>
                <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 深度学习</a>
                <a href="/tags/StyleTransfer/" rel="tag"><i class="fa fa-tag"></i> StyleTransfer</a>
                <a href="/tags/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90/" rel="tag"><i class="fa fa-tag"></i> 图像生成</a>
                <a href="/tags/%E9%A2%84%E7%A0%94/" rel="tag"><i class="fa fa-tag"></i> 预研</a>
            </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="原由："><a href="#原由：" class="headerlink" title="原由："></a><strong>原由</strong>：</h3><p>深度学习技术不仅落地难，找到合适需求点甚至更难。在一次头脑风暴中，同事提到或许可以尝试用深度学习手段解决手机ROM里主题图标包的问题，一下子就觉得这是个无论技术可行性、使用价值、技术壁垒都很有亮点的需求。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019-07-04-IconTransfer%20%E5%9B%BE%E6%A0%87%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E9%A2%84%E7%A0%94/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://benzblog.site/2019-06-25-%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://benzgallery.oss-cn-shanghai.aliyuncs.com/sailing_cat 1200.png">
      <meta itemprop="name" content="BenZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔哲明的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019-06-25-%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">语音识别初探</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-25T00:00:00+08:00">2019-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-08 23:53:31" itemprop="dateModified" datetime="2019-07-08T23:53:31+08:00">2019-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2019-06-25-%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E5%88%9D%E6%8E%A2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019-06-25-语音识别初探/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            
            <div class="post-tags" style="margin:5px">
                <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 机器学习</a>
                <a href="/tags/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/" rel="tag"><i class="fa fa-tag"></i> 语音识别</a>
                <a href="/tags/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86/" rel="tag"><i class="fa fa-tag"></i> 音频处理</a>
                <a href="/tags/ASR/" rel="tag"><i class="fa fa-tag"></i> ASR</a>
                <a href="/tags/%E5%94%A4%E9%86%92%E8%AF%8D/" rel="tag"><i class="fa fa-tag"></i> 唤醒词</a>
            </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>语音识别的基础知识讲解，包括传统方法和应用深度学习的方法。听声辩位的功能开发中使用到了简单的基于CNN的音频识别模型，为SharkTime自定义录屏功能扩展语音触发时，尝试了传统ASR方法。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019-06-25-%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E5%88%9D%E6%8E%A2/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://benzblog.site/2017-11-27-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8C%87%E5%8C%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://benzgallery.oss-cn-shanghai.aliyuncs.com/sailing_cat 1200.png">
      <meta itemprop="name" content="BenZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔哲明的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-11-27-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8C%87%E5%8C%97/" class="post-title-link" itemprop="url">推荐系统指北</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-27 00:00:00" itemprop="dateCreated datePublished" datetime="2017-11-27T00:00:00+08:00">2017-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-09 00:07:37" itemprop="dateModified" datetime="2019-07-09T00:07:37+08:00">2019-07-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MachineLearning/" itemprop="url" rel="index"><span itemprop="name">MachineLearning</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017-11-27-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8C%87%E5%8C%97/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017-11-27-推荐系统指北/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            
            <div class="post-tags" style="margin:5px">
                <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 机器学习</a>
                <a href="/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 推荐系统</a>
            </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>简单理顺推荐系统的几类方法，包括 协同过滤、content-based、model-based方法 等要点</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017-11-27-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%8C%87%E5%8C%97/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://benzblog.site/2017-06-19-all-about-rotations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://benzgallery.oss-cn-shanghai.aliyuncs.com/sailing_cat 1200.png">
      <meta itemprop="name" content="BenZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔哲明的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-06-19-all-about-rotations/" class="post-title-link" itemprop="url">Android屏幕旋转源码探索及应用实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-19 00:00:00" itemprop="dateCreated datePublished" datetime="2017-06-19T00:00:00+08:00">2017-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 23:22:20" itemprop="dateModified" datetime="2019-07-04T23:22:20+08:00">2019-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017-06-19-all-about-rotations/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017-06-19-all-about-rotations/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            
            <div class="post-tags" style="margin:5px">
                <a href="/tags/Android/" rel="tag"><i class="fa fa-tag"></i> Android</a>
                <a href="/tags/Frameworks/" rel="tag"><i class="fa fa-tag"></i> Frameworks</a>
                <a href="/tags/WMS/" rel="tag"><i class="fa fa-tag"></i> WMS</a>
            </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>在Android开发中，屏幕旋转是个很重要的知识点，但网上多是列举应用端的实现方法，少有深一步探索原因的。不久前工作中遇到不少旋转屏幕时的动画和时序问题，深为困扰，但在网上又找不到细致讲解原理的文章。   </p>
<p>本文试图从AOSP源码角度，讲解屏幕旋转和配置改变时系统和App都分别发生了什么，并据此给出应用开发时比较好的实践做法，包括如何强制设置旋转方向、如何应对生命周期变化和资源更新，对冗长的源码分析无感的同学可以直接看后面章节。  </p>
<p>(基于Android7.1.1源码，推荐源码阅读网站：<a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a>)  </p>
<h2 id="2-Rotation-与-Orientation区别"><a href="#2-Rotation-与-Orientation区别" class="headerlink" title="2 Rotation 与 Orientation区别"></a>2 Rotation 与 Orientation区别</h2><p>rotation 与 orientation 是相关但不同的概念。<br>orientation标识此时界面以什么方向显示，而且从词源上讲，这个方向可以是三维的；<br>而rotation是指平面内旋转的方向。      </p>
<table>
<thead>
<tr>
<th align="center">竖屏</th>
<th align="center">横屏</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img data-src="http://or5nesfx1.bkt.clouddn.com/screenshot_0614_portrait.png?imageView2/2/w/200/q/95" alt="竖屏"></td>
<td align="center"><img data-src="http://or5nesfx1.bkt.clouddn.com/screenshot_0614_landscape.png?imageView2/2/w/200/q/95" alt="横屏"></td>
</tr>
<tr>
<td align="center">WMS.mRotation == 0</td>
<td align="center">WMS.mRotation == 1</td>
</tr>
<tr>
<td align="center">screenOrientation == 1</td>
<td align="center">screenOrientation == 0</td>
</tr>
<tr>
<td align="center">Configuration.orientation == 1</td>
<td align="center">Configuration.orientation == 2</td>
</tr>
</tbody></table>
<h3 id="2-1-rotation"><a href="#2-1-rotation" class="headerlink" title="2.1 rotation"></a>2.1 rotation</h3><p>rotation旋转方向是指界面(不是手机)相对于默认情况顺时针旋转的角度，平板一般默认横屏，而小屏幕设备默认竖屏。<br>其值，定义在Surface.java中：  </p>
<pre><code>ROTATION_0 = 0, ROTATION_90 = 1, ROTATION_180 = 2, ROTATION_270 = 3  </code></pre><h3 id="2-2-orientation"><a href="#2-2-orientation" class="headerlink" title="2.2 orientation"></a>2.2 orientation</h3><p>orientation 分为两种，一个是在ActivityInfo.java中，另一个在Configuration.java。<br>前者具体来说是ActivityInfo.screenOrientation，这个值用于记录App强制设定的方向或旋转模式。具体代码如下：  </p>
<pre><code class="Java"><span class="comment">/**  </span>
<span class="comment"> * The preferred screen orientation this activity would like to run in.  </span>
<span class="comment"> * From the {<span class="doctag">@link</span> android.R.attr#screenOrientation} attribute, one of  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_UNSPECIFIED},  -1  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_LANDSCAPE},     0  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_PORTRAIT},      1  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_USER},          2  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_BEHIND},        3  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_SENSOR},          </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_NOSENSOR},  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_SENSOR_LANDSCAPE},  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_SENSOR_PORTRAIT},  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_REVERSE_LANDSCAPE},  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_REVERSE_PORTRAIT},  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_FULL_SENSOR},  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_USER_LANDSCAPE},  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_USER_PORTRAIT},  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_FULL_USER},  </span>
<span class="comment"> * {<span class="doctag">@link</span> #SCREEN_ORIENTATION_LOCKED},        14  </span>
<span class="comment"> */</span>  
<span class="meta">@ScreenOrientation</span>  
<span class="keyword">public</span> <span class="keyword">int</span> screenOrientation = SCREEN_ORIENTATION_UNSPECIFIED;  </code></pre>
<p>而Configuration.java中的orientation值可以认为只有两个，横屏或竖屏：  </p>
<pre><code class="Java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORIENTATION_UNDEFINED = <span class="number">0</span>;  
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORIENTATION_PORTRAIT = <span class="number">1</span>;  
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORIENTATION_LANDSCAPE = <span class="number">2</span>;  
<span class="meta">@Deprecated</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORIENTATION_SQUARE = <span class="number">3</span>;  </code></pre>
<p>当app具体渲染时候，不必在意具体旋转方向，区分横屏竖屏即可。  </p>
<h2 id="3-自动旋转开关"><a href="#3-自动旋转开关" class="headerlink" title="3 自动旋转开关"></a>3 自动旋转开关</h2><p>系统全局是否响应sensor的旋转做转屏是通过Settings中的“自动旋转”开关控制的：<br>开与关分别调用wms#thawRotation()和wms#freezeRotation。<br>这两个动作，主要是为了改PhoneWindowManager中两个值，mUserRotationMode和mUserRotation，前者控制是否自由旋屏，后者是旋转锁死时候的系统旋转方向。  </p>
<p>mUserRotationMode会有两种值，声明在WindowManagerPolicy中：  </p>
<pre><code class="Java"><span class="comment">/** When not otherwise specified by the activity's screenOrientation, rotation should be  </span>
<span class="comment"> * determined by the system (that is, using sensors). */</span>  
<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_ROTATION_FREE = <span class="number">0</span>;  
<span class="comment">/** When not otherwise specified by the activity's screenOrientation, rotation is set by  </span>
<span class="comment"> * the user. */</span>  
<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_ROTATION_LOCKED = <span class="number">1</span>;  </code></pre>
<p>在thawRotation开启自动旋转时，设置<code>mUserRotationMode</code>值为0。  </p>
<p>在freezeRotation时，除了设置<code>mUserRotationMode</code>为1，还会为<code>mUserRotation</code>赋值，一般是0，即竖屏方向，这样如果应用没有自行设置orientation，那么方向判断时就会使用这里的<code>mUserRotation</code>，从而尽可能保持竖屏。  </p>
<p>设置这两个值的具体过程还涉及到Setting、PhoneWindowManager.SettingObserver，有兴趣的可以看此处blog的详细代码和流程分析：<a href="http://blog.csdn.net/kc58236582/article/details/53671134" target="_blank" rel="noopener">WMS注册传感器回调</a>  </p>
<p><code>mUserRotationMode</code>和<code>mUserRotation</code>将在判断orientation的时候起到关键作用，在后续具体流程还会讲到。  </p>
<h2 id="4-旋转，从Sensor到onConfigurationChanged"><a href="#4-旋转，从Sensor到onConfigurationChanged" class="headerlink" title="4 旋转，从Sensor到onConfigurationChanged"></a>4 旋转，从Sensor到onConfigurationChanged</h2><p><img data-src="http://or5nesfx1.bkt.clouddn.com/RotationFlow.png" alt="旋转流程"><br>上图是一般情况下在应用内屏幕从竖屏旋转到竖屏时的调用流程图，这里我们分为三部分讲，包括WMS一侧rotation更新逻辑，AMS一侧的configuration控制逻辑，以及AMS将configuration分发到app和WMS的逻辑。  </p>
<h3 id="4-1-Sensor-gt-PWM-gt-WMS"><a href="#4-1-Sensor-gt-PWM-gt-WMS" class="headerlink" title="4.1 Sensor -&gt; PWM  -&gt; WMS"></a>4.1 Sensor -&gt; PWM  -&gt; WMS</h3><p>特别值得看的有两个地方：<br>一个是<code>WMS#updateRotationUnchecked()</code>，还有一个是<code>WMS#rotationForOrientationLw()</code>。  </p>
<p>updateRotationUnchecked方法可以看作是更新旋转的枢纽，它联系了PWM、AMS和WMS，代码如下：<br><strong>updateRotationUnchecked()</strong>  </p>
<pre><code class="Java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateRotationUnchecked</span><span class="params">(<span class="keyword">boolean</span> alwaysSendConfiguration, <span class="keyword">boolean</span> forceRelayout)</span> </span>{  
        ......  
        <span class="keyword">boolean</span> changed;  
        <span class="keyword">synchronized</span>(mWindowMap) {  
            changed = updateRotationUncheckedLocked(<span class="keyword">false</span>);  
            <span class="keyword">if</span> (!changed || forceRelayout) {  
                getDefaultDisplayContentLocked().layoutNeeded = <span class="keyword">true</span>;  
                mWindowPlacerLocked.performSurfacePlacement();  
            }  
        }  

        <span class="keyword">if</span> (changed || alwaysSendConfiguration) {  
            sendNewConfiguration();  
        }  

        Binder.restoreCallingIdentity(origId);  
    }  </code></pre>
<p>首先调用updateRotationUncheckedLocked()进行rotation的更新，而如果rotation有更新，则sendNewConfiguration()通知AMS更新configuration。  </p>
<p>而在updateRotationUncheckedLocked()中，也就是流程图中的5处，会通过下面这句计算得到新的rotation：  </p>
<pre><code>int rotation = mPolicy.rotationForOrientationLw(mLastOrientation, mRotation);  </code></pre><p>mLastOrientation和mRotation全局记录在WMS中，其中前者是应用显示方向，后者是生效的旋转方向。<br>这个方法是重点，因为我们需要知道对于不同应用不同环境，为什么有时候会旋转有时候不旋转，而这个方法的结果直接决定了系统是否发生旋转。方法具体如下：  </p>
<pre><code class="Java"><span class="meta">@Override</span>  
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rotationForOrientationLw</span><span class="params">(<span class="keyword">int</span> orientation, <span class="keyword">int</span> lastRotation)</span> </span>{  
        <span class="keyword">if</span> (<span class="keyword">false</span>) {  
            Slog.v(TAG, <span class="string">"rotationForOrientationLw(orient="</span>  
                        + orientation + <span class="string">", last="</span> + lastRotation  
                        + <span class="string">"); user="</span> + mUserRotation + <span class="string">" "</span>  
                        + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED)  
                            ? <span class="string">"USER_ROTATION_LOCKED"</span> : <span class="string">""</span>)  
                        );  
        }  

        <span class="keyword">if</span> (mForceDefaultOrientation) {  
            <span class="keyword">return</span> Surface.ROTATION_0;  
        }  

        <span class="keyword">synchronized</span> (mLock) {  
            <span class="keyword">int</span> sensorRotation = mOrientationListener.getProposedRotation(); <span class="comment">// may be -1  </span>
            <span class="keyword">if</span> (sensorRotation &lt; <span class="number">0</span>) {  
                sensorRotation = lastRotation;  
            }  

            <span class="keyword">final</span> <span class="keyword">int</span> preferredRotation;  
            <span class="keyword">if</span> (mLidState == LID_OPEN &amp;&amp; mLidOpenRotation &gt;= <span class="number">0</span>) {  
                <span class="comment">// Ignore sensor when lid switch is open and rotation is forced.  </span>
                preferredRotation = mLidOpenRotation;  
            }   
              ......  

              <span class="keyword">else</span> <span class="keyword">if</span> (mDemoRotationLock) {  
                <span class="comment">// Ignore sensor when demo rotation lock is enabled.  </span>
                <span class="comment">// Note that the dock orientation and HDMI rotation lock override this.  </span>
                preferredRotation = mDemoRotation;  
            } <span class="keyword">else</span> <span class="keyword">if</span> (orientation == ActivityInfo.SCREEN_ORIENTATION_LOCKED) {  
                <span class="comment">// Application just wants to remain locked in the last rotation.  </span>
                preferredRotation = lastRotation;  
            } <span class="keyword">else</span> <span class="keyword">if</span> (!mSupportAutoRotation) {  
                <span class="comment">// If we don't support auto-rotation then bail out here and ignore  </span>
                <span class="comment">// the sensor and any rotation lock settings.  </span>
                preferredRotation = -<span class="number">1</span>;  
            } <span class="keyword">else</span> <span class="keyword">if</span> ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE  
                            &amp;&amp; (orientation == ActivityInfo.SCREEN_ORIENTATION_USER  
                                    || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED  
                                    || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE  
                                    || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT  
                                    || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER))  
                    || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR  
                    || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR  
                    || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE  
                    || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {  
                <span class="comment">// Otherwise, use sensor only if requested by the application or enabled  </span>
                <span class="comment">// by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.  </span>
                <span class="keyword">if</span> (mAllowAllRotations &lt; <span class="number">0</span>) {  
                    <span class="comment">// Can't read this during init() because the context doesn't  </span>
                    <span class="comment">// have display metrics at that time so we cannot determine  </span>
                    <span class="comment">// tablet vs. phone then.  </span>
                    mAllowAllRotations = mContext.getResources().getBoolean(  
                            com.android.internal.R.bool.config_allowAllRotations) ? <span class="number">1</span> : <span class="number">0</span>;  
                }  
                <span class="keyword">if</span> (sensorRotation != Surface.ROTATION_180  
                        || mAllowAllRotations == <span class="number">1</span>  
                        || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR  
                        || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER) {  
                    preferredRotation = sensorRotation;  
                } <span class="keyword">else</span> {  
                    preferredRotation = lastRotation;  
                }  
            } <span class="keyword">else</span> <span class="keyword">if</span> (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED  
                    &amp;&amp; orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {  
                <span class="comment">// Apply rotation lock.  Does not apply to NOSENSOR.  </span>
                <span class="comment">// The idea is that the user rotation expresses a weak preference for the direction  </span>
                <span class="comment">// of gravity and as NOSENSOR is never affected by gravity, then neither should  </span>
                <span class="comment">// NOSENSOR be affected by rotation lock (although it will be affected by docks).  </span>
                preferredRotation = mUserRotation;  
            } <span class="keyword">else</span> {  
                <span class="comment">// No overriding preference.  </span>
                <span class="comment">// We will do exactly what the application asked us to do.  </span>
                preferredRotation = -<span class="number">1</span>;  
            }  

            <span class="keyword">switch</span> (orientation) {  
                <span class="keyword">case</span> ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:  
                    <span class="comment">// Return portrait unless overridden.  </span>
                    <span class="keyword">if</span> (isAnyPortrait(preferredRotation)) {  
                        <span class="keyword">return</span> preferredRotation;  
                    }  
                    <span class="keyword">return</span> mPortraitRotation;  

                <span class="keyword">case</span> ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:  
                    <span class="comment">// Return landscape unless overridden.  </span>
                    <span class="keyword">if</span> (isLandscapeOrSeascape(preferredRotation)) {  
                        <span class="keyword">return</span> preferredRotation;  
                    }  
                    <span class="keyword">return</span> mLandscapeRotation;  

                ......  

                <span class="keyword">default</span>:  
                    <span class="comment">// For USER, UNSPECIFIED, NOSENSOR, SENSOR and FULL_SENSOR,  </span>
                    <span class="comment">// just return the preferred orientation we already calculated.  </span>
                    <span class="keyword">if</span> (preferredRotation &gt;= <span class="number">0</span>) {  
                        <span class="keyword">return</span> preferredRotation;  
                    }  
                    <span class="keyword">return</span> Surface.ROTATION_0;  
            }  
        }  
    }  </code></pre>
<p>这个函数前面的if-else主要是结合当前系统显示模式、旋转模式以及sensor监测到的旋转方向给出一个preferredRotation，后面的switch-case则是根据当前的orientation决定是否可以使用preferredRotation。<br>下面我们从两个具体情况看这段代码做了什么，<a href="#SCREEN_ORIENTATION_UNSPECIFIED">应用不设置横竖屏的情况</a>以及<a href="#SCREEN_ORIENTATION_PORTRAIT">应用设置强制竖屏的情况</a>  </p>
<h4 id="4-1-1-应用不设置横竖屏的情况"><a href="#4-1-1-应用不设置横竖屏的情况" class="headerlink" title="4.1.1 应用不设置横竖屏的情况"></a><span id="4_1_1">4.1.1</span> <span id="SCREEN_ORIENTATION_UNSPECIFIED">应用不设置横竖屏的情况</span></h4><p>对于一个没有设置screenOrientation的应用来说，一次竖屏旋转到横屏，wms是如何判定orientation的?  </p>
<pre><code>int rotation = mPolicy.rotationForOrientationLw(mLastOrientation, mRotation);  </code></pre><p>在上面一行代码中，<code>mLastOrientation</code>此时为应用的screenOrientation值  -1（UNSPECIFIED）,<code>mRotatiton</code>是上次竖屏的值0。<br>然后进入orientationForRotation()    </p>
<pre><code>int sensorRotation = mOrientationListener.getProposedRotation(); // may be -1  </code></pre><p>要转到竖屏，所以此时sensorRotation为1。在后续判断中，首先根据各种系统此时的显示模式以及应用的orientationMode计算preferredRotation。在当前情况下，会走到90行  </p>
<pre><code>preferredRotation = sensorRotation;  </code></pre><p>并且由于当前orientation是SCREEN_ORIENTATION_UNSPECIFIED（应用未设置）的，最后会在130行将preferredRotation(==1)作为结果返回。<br>随后WMS将<code>mRotation</code>值更新为1，并继续根据该值更新displayInfo等信息，<br>具体更新displayInfo等相关内容的流程这里不再详解，大致意思就是一层层重新计算display的长宽，最终给到设备底层，具体代码流程分析可以看<a href="http://blog.csdn.net/kc58236582/article/details/53689526" target="_blank" rel="noopener">此处</a>。  </p>
<p>除了dissplayInfo的更新，这里还创建了旋转动画，与动画相关的具体在下文第7节讲解。<br>这些WMS系统显示层相关东西搞定后，回到<code>WMS#updateRotationUnchecked</code>，此时changed为true，即configuration有变化，调用<strong>AMS#updateConfiguration</strong>更新configuration。  </p>
<p>下面看看应用如果设置了强制竖屏时，rotationForOrientationLw返回的结果如何。  </p>
<h4 id="4-1-2-应用设置强制竖屏的情况"><a href="#4-1-2-应用设置强制竖屏的情况" class="headerlink" title="4.1.2 应用设置强制竖屏的情况"></a>4.1.2 <span id="SCREEN_ORIENTATION_PORTRAIT">应用设置强制竖屏的情况</span></h4><p>应用强制设置竖屏的方式将在第5节中具体讲，<br>可以确定的一点是，在成功设置好竖屏后，且没关闭系统自动旋转开关的情况下，几个关键的变量如下：<br>WMS.mLastOrientation == 1, WMS.mRotation == 0,<br>PWM.mUserRotationMode == 0 (ROTATION_FREE), PWM.mUserRotation == 0。  </p>
<p>然后我们将手机从竖屏旋转到横屏，在<code>rotationForOrientationLw()</code>中进行判断时，虽然<code>UserRotationMode</code>是FREE的，但<code>mLastOrientation</code>却并不属于67~76行的条件中的一个，preferredRotation不能使用sensorRotation，且在后面switch(orientation)是，对于ORIENTATION_PORTRAIT的情况，实际上preferredRotation也是不会生效的，无论如何都会返回0，也就是说应用设定的orientation优先级总是最高的。  </p>
<p>WMS拿到0的结果后，由于与已有的<code>mRotation</code>值相同，会中断后续逻辑，对旋转不做任何反应，由于没有向AMS更新configuration，所以也不会有onConfigurationChanged过程，其它app也不会知道发生了旋转。  </p>
<h3 id="4-2-AMS"><a href="#4-2-AMS" class="headerlink" title="4.2 AMS"></a>4.2 AMS</h3><p>回到WMS#updateRotationUnchecked()，在确定rotation更新后changed==true，执行方法sendNewConfiguration() -&gt; AMS#updateConfiguration 通知AMS更新configuration。  </p>
<p><strong>AMS#updateConfiguration()</strong>  </p>
<pre><code>public void updateConfiguration(Configuration values) {  
    enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,  
            &quot;updateConfiguration()&quot;);  

    synchronized(this) {  
        if (values == null &amp;&amp; mWindowManager != null) {  
            // sentinel: fetch the current configuration from the window manager  
            values = mWindowManager.computeNewConfiguration();  
        }  

        if (mWindowManager != null) {  
            mProcessList.applyDisplaySize(mWindowManager);  
        }  

        final long origId = Binder.clearCallingIdentity();  
        if (values != null) {  
            Settings.System.clearConfiguration(values);  
        }  
        updateConfigurationLocked(values, null, false);  
        Binder.restoreCallingIdentity(origId);  
    }  
}  </code></pre><p>入参values这时候为空，首先从WMS重新获取一遍，生成一个新的Configuration，然后进入方法updateConfigurationLocked()<br><span id="ams_updateconfiglocked"><strong>ActivityManagerService#updateConfigurationLocked</strong></span>  </p>
<pre><code class="Java"><span class="comment">/**  </span>
<span class="comment"> * Do either or both things: (1) change the current configuration, and (2)  </span>
<span class="comment"> * make sure the given activity is running with the (now) current  </span>
<span class="comment"> * configuration.  Returns true if the activity has been left running, or  </span>
<span class="comment"> * false if &lt;var&gt;starting&lt;/var&gt; is being destroyed to match the new  </span>
<span class="comment"> * configuration.  </span>
<span class="comment"> *  </span>
<span class="comment"> * <span class="doctag">@param</span> userId is only used when persistent parameter is set to true to persist configuration  </span>
<span class="comment"> *               for that particular user  </span>
<span class="comment"> */</span>  
<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateConfigurationLocked</span><span class="params">(Configuration values, ActivityRecord starting,  </span></span>
<span class="function"><span class="params">        <span class="keyword">boolean</span> initLocale, <span class="keyword">boolean</span> persistent, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> deferResume)</span> </span>{  
    <span class="keyword">int</span> changes = <span class="number">0</span>;  

    <span class="keyword">if</span> (mWindowManager != <span class="keyword">null</span>) {  
        mWindowManager.deferSurfaceLayout();  
    }  
    <span class="keyword">if</span> (values != <span class="keyword">null</span>) {  
        Configuration newConfig = <span class="keyword">new</span> Configuration(mConfiguration);  
        changes = newConfig.updateFrom(values); <span class="comment">//copy更新，同时以flags的方式记录区别  </span>
        <span class="keyword">if</span> (changes != <span class="number">0</span>) {  
            ......  
            mConfigurationSeq++;  
            <span class="keyword">if</span> (mConfigurationSeq &lt;= <span class="number">0</span>) {  
                mConfigurationSeq = <span class="number">1</span>;  
            }  
            newConfig.seq = mConfigurationSeq; <span class="comment">//序列号，可用来略过旧的config  </span>
            mConfiguration = newConfig; <span class="comment">//保存新configuration  </span>
            ......  
            <span class="keyword">final</span> Configuration configCopy = <span class="keyword">new</span> Configuration(mConfiguration);  
            ......  

            <span class="keyword">for</span> (<span class="keyword">int</span> i=mLruProcesses.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) {  
                ProcessRecord app = mLruProcesses.get(i);  
                <span class="keyword">try</span> {  
                    <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) {  
                        <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION, <span class="string">"Sending to proc "</span>  
                                + app.processName + <span class="string">" new config "</span> + mConfiguration);  
                        app.thread.scheduleConfigurationChanged(configCopy);  
                    }  
                } <span class="keyword">catch</span> (Exception e) {  
                }  
            }  
            Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CONFIGURATION_CHANGED);  
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY  
                    | Intent.FLAG_RECEIVER_REPLACE_PENDING  
                    | Intent.FLAG_RECEIVER_FOREGROUND);  
            broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,  
                    <span class="keyword">null</span>, AppOpsManager.OP_NONE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,  
                    MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL);  
            <span class="keyword">if</span> ((changes&amp;ActivityInfo.CONFIG_LOCALE) != <span class="number">0</span>) {  
                intent = <span class="keyword">new</span> Intent(Intent.ACTION_LOCALE_CHANGED);  
                intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);  
                <span class="keyword">if</span> (initLocale || !mProcessesReady) {  
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);  
                }  
                broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent,  
                        <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE,  
                        <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL);  
            }  
            ......  
        }  
        <span class="comment">// Update the configuration with WM first and check if any of the stacks need to be  </span>
        <span class="comment">// resized due to the configuration change. If so, resize the stacks now and do any  </span>
        <span class="comment">// relaunches if necessary. This way we don't need to relaunch again below in  </span>
        <span class="comment">// ensureActivityConfigurationLocked().  </span>
        <span class="keyword">if</span> (mWindowManager != <span class="keyword">null</span>) {  
            <span class="keyword">final</span> <span class="keyword">int</span>[] resizedStacks = mWindowManager.setNewConfiguration(mConfiguration);  
            <span class="keyword">if</span> (resizedStacks != <span class="keyword">null</span>) {  
                <span class="keyword">for</span> (<span class="keyword">int</span> stackId : resizedStacks) {  
                    <span class="keyword">final</span> Rect newBounds = mWindowManager.getBoundsForNewConfiguration(stackId);  
                    mStackSupervisor.resizeStackLocked(  
                            stackId, newBounds, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, deferResume);  
                }  
            }  
        }  
    }  

    <span class="keyword">boolean</span> kept = <span class="keyword">true</span>;  
    <span class="keyword">final</span> ActivityStack mainStack = mStackSupervisor.getFocusedStack();  
    <span class="comment">// mainStack is null during startup.  </span>
    <span class="keyword">if</span> (mainStack != <span class="keyword">null</span>) {  
        <span class="keyword">if</span> (changes != <span class="number">0</span> &amp;&amp; starting == <span class="keyword">null</span>) {  
            <span class="comment">// If the configuration changed, and the caller is not already  </span>
            <span class="comment">// in the process of starting an activity, then find the top  </span>
            <span class="comment">// activity to check if its configuration needs to change.  </span>
            starting = mainStack.topRunningActivityLocked();  
        }  

        <span class="keyword">if</span> (starting != <span class="keyword">null</span>) {  
            kept = mainStack.ensureActivityConfigurationLocked(starting, changes, <span class="keyword">false</span>);  
            <span class="comment">// And we need to make sure at this point that all other activities  </span>
            <span class="comment">// are made visible with the correct configuration.  </span>
            mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes,  
                    !PRESERVE_WINDOWS);  
        }  
    }  
    <span class="keyword">if</span> (mWindowManager != <span class="keyword">null</span>) {  
        mWindowManager.continueSurfaceLayout();  
    }  
    <span class="keyword">return</span> kept;  
}  
</code></pre>
<p>代码略长，上面已经略去很多这里不会讲的内容。<br>整个方法先前后通过<code>mWindowManager.deferSurfaceLayout()</code>和<code>mWindowManager.continueSurfaceLayout()</code>包起来，毕竟config变动布局等影响很大，许多状态变化会触发到surfacelayout，通过这种方式避免重复刷新。<br>首先将新config保存到mConfiguration中，然后是关键的33<del>43行:<br>遍历mLruProcesses，调用appThread.scheduleConfigurationChanged，对应的ActivityThread随后进入onConfigurationChanged相关流程，app侧的处理下面会再细讲。<a href="#4_3_schedulConfig">跳转</a><br>除此之外，44</del>66行，updateConfigurationChanged()还会发出ACTION_CONFIGURATION_CHANGED的广播，似乎是留给其它service接收该广播做其他事情的。<br>再之后，图中流程15，调用WMS#setNewConfiguration回到WMS:  </p>
<pre><code>@Override  
    public int[] setNewConfiguration(Configuration config) {  
        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,  
                &quot;setNewConfiguration()&quot;)) {  
            throw new SecurityException(&quot;Requires MANAGE_APP_TOKENS permission&quot;);  
        }  

        synchronized(mWindowMap) {  
            if (mWaitingForConfig) {  
                mWaitingForConfig = false;  
                mLastFinishedFreezeSource = &quot;new-config&quot;;  
            }  
            boolean configChanged = mCurConfiguration.diff(config) != 0;  
            if (!configChanged) {  
                return null;  
            }  
            prepareFreezingAllTaskBounds();  
            mCurConfiguration = new Configuration(config);  
            return onConfigurationChanged();  
        }  
    }  </code></pre><p>这个方法主要是向WMS更新mCurConfiguration。是的，WMS此时才更新到新的Configuration，之前WMS的逻辑主要是在display和phone层面上的动作，最关键的修改是mRotation，而这里则扩展到了Configuration领域的动作，主题、字体、bounds的改变都是configuration的改变，AMS在逻辑层面更有话语权，而此时WMS响应新的配置项，并调用WMS#onConfigurationChanged()。<br>不过在更早的<a href="http://androidxref.com/6.0.0_r5/xref/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java#4037" target="_blank" rel="noopener">android版本</a>上，这里并没有这么多的操作，会直接就进行surfaceLayout(现在延迟到continueSurfaceLayout了)，这里增加的内容主要为了提前响应非全屏应用的bounds的改变，尤其有不少为分屏stack量身定制的逻辑，这里就不再细讲了。  </p>
<p>在刷新界面之前，还有很重要的一部分逻辑，91行：  </p>
<pre><code>kept = mainStack.ensureActivityConfigurationLocked(starting, changes, false);  
// And we need to make sure at this point that all other activities  
// are made visible with the correct configuration.  
mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes, !PRESERVE_WINDOWS);  </code></pre><p>然后进入<strong>ActivityStack#ensureActivityConfigurationLocked</strong>  </p>
<pre><code>/**  
 * Make sure the given activity matches the current configuration. Returns false if the activity  
 * had to be destroyed.  Returns true if the configuration is the same, or the activity will  
 * remain running as-is for whatever reason. Ensures the HistoryRecord is updated with the  
 * correct configuration and all other bookkeeping is handled.  
 */  
boolean ensureActivityConfigurationLocked(  
        ActivityRecord r, int globalChanges, boolean preserveWindow) {  
    ......  

    if ((changes&amp;(~r.info.getRealConfigChanged())) != 0 || r.forceNewConfig) {  
        // Aha, the activity isn&apos;t handling the change, so DIE DIE DIE.  
        r.configChangeFlags |= changes;  
        r.startFreezingScreenLocked(r.app, globalChanges);  
        r.forceNewConfig = false;  
        preserveWindow &amp;= isResizeOnlyChange(changes);  
        if (r.app == null || r.app.thread == null) {  
            ......  
        } else if (r.state == ActivityState.RESUMED) {  
            // Try to optimize this case: the configuration is changing and we need to restart  
            // the top, resumed activity. Instead of doing the normal handshaking, just say  
            // &quot;restart!&quot;.  
            relaunchActivityLocked(r, r.configChangeFlags, true, preserveWindow);  
        } else {  
            if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,  
                    &quot;Config is relaunching non-resumed &quot; + r);  
            relaunchActivityLocked(r, r.configChangeFlags, false, preserveWindow);  
        }  

        // All done...  tell the caller we weren&apos;t able to keep this activity around.  
        return false;  
    }  

    // Default case: the activity can handle this new configuration, so hand it over.  
    // NOTE: We only forward the task override configuration as the system level configuration  
    // changes is always sent to all processes when they happen so it can just use whatever  
    // system level configuration it last got.  
    r.scheduleConfigurationChanged(taskConfig, true);  
    r.stopFreezingScreenLocked(false);  

    return true;  
}  </code></pre><p>注释已经将此方法解释得很好：确保activity的Configuration更新，如果应用没有针对该类改变做特殊处理，那么不得不重启应用，走relaunch流程；相反，如果应用能够在handle当前的变化，那么走scheduleConfigurationChanged-&gt;onConfigurationChanged流程。这里的两个分支判断细节在后面会用具体例子讲解，这里先继续讲relauch流程部分。  </p>
<p>relaunch流程很长，简单的说就是把应用重启了一遍，我们跳过各种binder调用，直接到app一侧并择取其中关键易懂的：<br><strong>android.app.ActivityThread#handleRelaunchActivity()</strong>  </p>
<pre><code>private void handleRelaunchActivity(ActivityClientRecord tmp) {  
    ......  
    // Need to ensure state is saved.  
    if (!r.paused) {  
        performPauseActivity(r.token, false, r.isPreHoneycomb(), &quot;handleRelaunchActivity&quot;);  
    }  
    if (r.state == null &amp;&amp; !r.stopped &amp;&amp; !r.isPreHoneycomb()) {  
        callCallActivityOnSaveInstanceState(r);  
    }  

    handleDestroyActivity(r.token, false, configChanges, true);  
    ......  
    handleLaunchActivity(r, currentIntent, &quot;handleRelaunchActivity&quot;);  
    ......  
}  </code></pre><p>可以看到，代码里顺次进行了pause、destroy、launch，前面两个就是一般意义上的onPause、onDestroy生命周期。<br>而launch流程，它则是与一般的start流程<sup id="fnref:1"><a href="#fn:1" rel="footnote">&lt;span class=”hint–top hint–error hint–medium hint–rounded hint–bounce” aria-label=”LocalActivityManager#moveToState(INITIALIZING)-&gt;startActivityNow() 和 handleLaunch() 都会走到performLaunchActivity() -&gt; onStart() -&gt; onCreate()  </p>
<p>  “&gt;<a href="http://or5nesfx1.bkt.clouddn.com/screenshot_0614_portrait.png?imageView2/2/w/200/q/95" target="_blank" rel="noopener">1</a></span></a></sup>一样的，relaunch就是我们常说的旋转屏幕时Activity会销毁重建的原因。<br>然后我们还看到第8行调用了onSaveInstanceState，所以应对屏幕旋转时的重新实例化的改变，通常需要在onSaveInstanceState()中保留必要的现场数据，应对屏幕旋转的其它技术细节见第6节。  </p>
<p>回到AMS，除了对top应用的处理，还有对其它activities的处理。ensureActivitiesVisibleLocked将会遍历task，确定其它的activity的visible和configuration状态都正常，如果还有需要显示的activity（例如前台是透明应用的情况），也要走一遍<code>ensureActivityConfigurationLocked</code>流程。  </p>
<h3 id="4-3-AMS-gt-AppThread-onConfigurationChanged"><a href="#4-3-AMS-gt-AppThread-onConfigurationChanged" class="headerlink" title="4.3 AMS -&gt; AppThread.onConfigurationChanged"></a><span id="4_3_schedulConfig">4.3 AMS -&gt; AppThread.onConfigurationChanged</span></h3><p>首先给出结论，只要系统AMS里的configuration确认发生了变化，所有app都会接收到新的configuration，并根据其配置可能执行onConfigurationChanged方法。  </p>
<p>在上一节<a href="#ams_updateconfiglocked">AMS#updateConfigurationLocked</a>方法中，我们讲到其会遍历mLruProcesses，对每个appThread调用scheduleConfigurationChanged接口，这里我们讲一讲app在config变化后都做了什么以及如何继续步入onConfigurationChanged方法，流程图如下<br><img data-src="http://or5nesfx1.bkt.clouddn.com/configurationChange_flow.png" alt="onConfigurationChanged流程图"><br>首先在2.updatePendingConfiguration里把新值保存在mPendingConfiguration里，丢出msg，AMS继续遍历，app侧在handleConfigurationChanged继续处理。<br>紧接着，执行4.applyConfigurationToResourcesLocked，顾名思义，讲config应用到resource上，可以想见，这里将会遍历resource，按照config的变化刷新资源，具体是交给ResourcesImpl.updateConfiguration处理，值得细看，但我对resource不太熟悉，就不细讲了。<br>接下来collectComponentCallbacks()，收集应用的组件，再遍历组件执行performConfigurationChanged(cb)，这也是我们比较关心的地方。<br>这个方法里主要是判断一下当前config的改变是否应该触发onConfigurationChanged，后面也有例子细讲。<br>再接下来正式进入各个组件的onConfigurationChanged方法，在service、contentprovider中都是空方法，activity有些不同：  </p>
<pre><code>public void onConfigurationChanged(Configuration newConfig) {  
    if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onConfigurationChanged &quot; + this + &quot;: &quot; + newConfig);  
    mCalled = true;  

    mFragments.dispatchConfigurationChanged(newConfig);  

    if (mWindow != null) {  
        // Pass the configuration changed event to the window  
        mWindow.onConfigurationChanged(newConfig);  
    }  

    if (mActionBar != null) {  
        // Do this last; the action bar will need to access  
        // view changes from above.  
        mActionBar.onConfigurationChanged(newConfig);  
    }  
}  </code></pre><p><strong>最后再总结下Activity在发生旋转时重要的生命周期：</strong>  </p>
<ul>
<li>如果acitivityInfo.getRealConfigChanged() 不能cover住当前config发生的改变：<br>转屏 -&gt; onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume  </li>
<li>相反，如果config的变化应用自行可以处理：<br>转屏 -&gt; 只会执行onConfigurationChanged  </li>
</ul>
<p>在网上有类说法如下：  </p>
<blockquote>
<p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次<br>设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法  </p>
</blockquote>
<p>请注意，这种说法<strong>完全不对</strong>，再怎么说，生命周期怎么可能重复执行两次呢，那是要有多么的浪费资源，框架不可能设计得那么差，这个时候就得想想是不是自己的代码写错了。<br>另外orientation 也与 keyboardHidden是两类不同的标签，二者没有关系，在API13以后orientation需要与screenSize配合使用，这是因为横竖屏切换不仅变方向同时也有屏幕大小的变化。详情见<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html?hl=zh-cn#HandlingTheChange" target="_blank" rel="noopener">官方文档</a>。  </p>
<h2 id="5-应用强制横屏竖屏"><a href="#5-应用强制横屏竖屏" class="headerlink" title="5 应用强制横屏竖屏"></a>5 应用强制横屏竖屏</h2><p>应用强制设置屏幕方向，就我所知有两种方式，一种是在manifest里设定，一种是在代码里通过setOrientation设定，接下来分别讲解具体方法以及原理。  </p>
<h3 id="5-1-静态-screenOrientation属性"><a href="#5-1-静态-screenOrientation属性" class="headerlink" title="5.1 静态 screenOrientation属性"></a>5.1 静态 screenOrientation属性</h3><p>假设需要强制竖屏，修改ActivityManifest.xml对应的activity元素里的内容如下即可：  </p>
<pre><code class="xml"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>  </span>
<span class="tag">            <span class="attr">android:screenOrientation</span>=<span class="string">"portrait"</span>&gt;</span>  </code></pre>
<p>还有更多属性值用法见<a href="https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn#screen" target="_blank" rel="noopener">官方文档</a>。  </p>
<p>这里网上有说法认为使用了screenOrientation也应该同时使用configChanges，这样可以避免 应用在后台时由于其它应用的旋转切换回本应用时会onCreate<sup id="fnref:1"><a href="#fn:1" rel="footnote">&lt;span class=”hint–top hint–error hint–medium hint–rounded hint–bounce” aria-label=”LocalActivityManager#moveToState(INITIALIZING)-&gt;startActivityNow() 和 handleLaunch() 都会走到performLaunchActivity() -&gt; onStart() -&gt; onCreate()  </p>
<p>  “&gt;<a href="http://or5nesfx1.bkt.clouddn.com/screenshot_0614_portrait.png?imageView2/2/w/200/q/95" target="_blank" rel="noopener">1</a></span></a></sup>。  </p>
<p>这种问题意味着多走了relaunch流程，我实测了下未出现此种问题。<br>在resume一个应用时，确实会再次做ensureActivityConfig，ActivityStack#resumeTopActivityInnerLocked()中有如下一段代码：  </p>
<pre><code>// Have the window manager re-evaluate the orientation of  
// the screen based on the new activity order.  
boolean notUpdated = true;  
if (mStackSupervisor.isFocusedStack(this)) {  
    Configuration config = mWindowManager.updateOrientationFromAppTokens(  
            mService.mConfiguration,  
            next.mayFreezeScreenLocked(next.app) ? next.appToken : null);  
    if (config != null) {  
        next.frozenBeforeDestroy = true;  
    }  
    notUpdated = !mService.updateConfigurationLocked(config, next, false);  
}  </code></pre><p>第11行updateConfigurationLocked是之前讲到的AMS更新config的方法，方法内会执行ensureActivityConfig()<br>但我们可以看到，在updateConfigurationLocked之前，第5行重新从wms计算了一遍config，而这个config在下面ensureAtyConfig判断时，会发现前后Aty已有的config与此值一样，所以正常不应该再走relaunch流程。<br>不过有鉴于异常情况总会意想不到地出现，这里还是<strong>推荐增加相应configChanges属性值</strong>。  </p>
<h3 id="5-2-动态-setRequestedOrientation"><a href="#5-2-动态-setRequestedOrientation" class="headerlink" title="5.2 动态 setRequestedOrientation"></a>5.2 动态 setRequestedOrientation</h3><p>上一小节我们讲了静态修改的方法，接下来是用代码动态生效的方法。  </p>
<p>代码动态修改orientation为横屏，例子如下：  </p>
<pre><code>setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE)  </code></pre><p>直接在activity中执行该方法即可，它会调用到AMS#setRequestedOrientation()，并最终执行WMS#setAppOrientation来修改AppToken.requestOrientation的值，用于保存应用设定的屏幕方向。<br>其实，前面静态设置屏幕方向的screenOrientation值，最终也是传递到了AppToken.requestOrientation<sup id="fnref:1"><a href="#fn:1" rel="footnote">&lt;span class=”hint–top hint–error hint–medium hint–rounded hint–bounce” aria-label=”LocalActivityManager#moveToState(INITIALIZING)-&gt;startActivityNow() 和 handleLaunch() 都会走到performLaunchActivity() -&gt; onStart() -&gt; onCreate()  </p>
<p>  “&gt;<a href="http://or5nesfx1.bkt.clouddn.com/screenshot_0614_portrait.png?imageView2/2/w/200/q/95" target="_blank" rel="noopener">1</a></span></a></sup>才生效，二者殊途同归。  </p>
<p>那么这个值究竟又是如何影响屏幕旋转方向的呢？  </p>
<h3 id="5-3-应用强制屏幕方向生效原理"><a href="#5-3-应用强制屏幕方向生效原理" class="headerlink" title="5.3 应用强制屏幕方向生效原理"></a>5.3 应用强制屏幕方向生效原理</h3><p>前面 4.1.1 和 4.1.2 具体讲解了WMS如何判断决定屏幕方向，主要通过PWM.rotationForOrientationLw方法，而这个方法里，screenOrientation几乎是起决定性作用的，这个参数的值则是WMS.mLastOrientation。全局搜索这个WMS.mLastOrientation的引用，发现只有一个写操作的地方：WMS#updateOrientationFromAppTokensLocked(boolean)。  </p>
<p><strong>WindowManagerService#updateOrientationFromAppTokensLocked(boolean)</strong>  </p>
<pre><code class="Java"><span class="comment">/*  </span>
<span class="comment"> * Determine the new desired orientation of the display, returning  </span>
<span class="comment"> * a non-null new Configuration if it has changed from the current  </span>
<span class="comment"> * orientation.  IF TRUE IS RETURNED SOMEONE MUST CALL  </span>
<span class="comment"> * setNewConfiguration() TO TELL THE WINDOW MANAGER IT CAN UNFREEZE THE  </span>
<span class="comment"> * SCREEN.  This will typically be done for you if you call  </span>
<span class="comment"> * sendNewConfiguration().  </span>
<span class="comment"> *  </span>
<span class="comment"> * The orientation is computed from non-application windows first. If none of  </span>
<span class="comment"> * the non-application windows specify orientation, the orientation is computed from  </span>
<span class="comment"> * application tokens.  </span>
<span class="comment"> * @see android.view.IWindowManager#updateOrientationFromAppTokens(  </span>
<span class="comment"> * android.os.IBinder)  </span>
<span class="comment"> */</span>  
<span class="function"><span class="keyword">boolean</span> <span class="title">updateOrientationFromAppTokensLocked</span><span class="params">(<span class="keyword">boolean</span> inTransaction)</span> </span>{  
    <span class="keyword">long</span> ident = Binder.clearCallingIdentity();  
    <span class="keyword">try</span> {  
        <span class="keyword">int</span> req = getOrientationLocked();  
        <span class="keyword">if</span> (req != mLastOrientation) {  
            mLastOrientation = req;  
            <span class="comment">//send a message to Policy indicating orientation change to take  </span>
            <span class="comment">//action like disabling/enabling sensors etc.,  </span>
            mPolicy.setCurrentOrientationLw(req);  
            <span class="keyword">if</span> (updateRotationUncheckedLocked(inTransaction)) {  
                <span class="comment">// changed  </span>
                <span class="keyword">return</span> <span class="keyword">true</span>;  
            }  
        }  

        <span class="keyword">return</span> <span class="keyword">false</span>;  
    } <span class="keyword">finally</span> {  
        Binder.restoreCallingIdentity(ident);  
    }  
}  </code></pre>
<p>在此方法中，通过getOrientationLocked()计算并更新mLastOrientation的值。具体计算过程大致就是注释里第9行开始说的，先根据系统状态看是否有确定的orientation（比如锁屏时一般就只能是portrait），如果没有，则取前台应用appToken里的requestedOrientation拿来用。<br>WMS#updateOrientationFromAppTokensLocked通常在应用resume时被调用，它的调用流程见下一节流程图。  </p>
<p>所以我们可以总结出应用强制设置orientation的数据流图大概如下：<br><img data-src="http://or5nesfx1.bkt.clouddn.com/prief_force_orientation_flow.png" alt="数据流">  </p>
<h3 id="5-4-横屏应用载入流程"><a href="#5-4-横屏应用载入流程" class="headerlink" title="5.4 横屏应用载入流程"></a>5.4 横屏应用载入流程</h3><p>这个就直接窃用网上<a href="http://blog.csdn.net/guoqifa29/article/details/40504189" target="_blank" rel="noopener">博客</a>图了，各个方法前面基本也都有讲到，这里就略过了。<br><img data-src="http://or5nesfx1.bkt.clouddn.com/landscape_start_flow.png" alt="landscape_start_flow">  </p>
<h2 id="6-更好的应对旋转布局变化以及持久化"><a href="#6-更好的应对旋转布局变化以及持久化" class="headerlink" title="6 更好的应对旋转布局变化以及持久化"></a>6 更好的应对旋转布局变化以及持久化</h2><h3 id="6-1-在onConfigurationChanged里处理configuration的变化，避免重新实例化"><a href="#6-1-在onConfigurationChanged里处理configuration的变化，避免重新实例化" class="headerlink" title="6.1 在onConfigurationChanged里处理configuration的变化，避免重新实例化"></a>6.1 在onConfigurationChanged里处理configuration的变化，避免重新实例化</h3><p>自行处理配置变更，官方文档<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html?hl=zh-cn#HandlingTheChange" target="_blank" rel="noopener">在此</a>，简单来说需要做两件事情：  </p>
<ol>
<li>在manifest的<activity>标签里增加configChanges属性，例如，如果你准备在onConfigurationChanged处理旋转屏幕的情况，要这样写：  </li>
</ol>
<pre><code>&lt;activity android:name=&quot;.MyActivity&quot;  
          android:configChanges=&quot;orientation|screenSize&quot;  
          android:label=&quot;@string/app_name&quot;&gt;  </code></pre><ol start="2">
<li>重写各个组件的onConfigurationChanged方法  </li>
</ol>
<p>接下来从代码流程上讲下这种处理方式的原理：<br>在上面AMS#ensureActivityConfigurationLocked里我们提到，应用要么走relaunch重新实例化的流程，要么scheduleConfigurationChanged走onConfigurationChanged流程。而这里我们希望是后者。<br><strong>ActivityStack#ensureActivityConfigurationLocked</strong>  </p>
<pre><code>boolean ensureActivityConfigurationLocked(  
        ActivityRecord r, int globalChanges, boolean preserveWindow) {  
    ......  

    if ((changes&amp;(~r.info.getRealConfigChanged())) != 0 || r.forceNewConfig) {  
        // Aha, the activity isn&apos;t handling the change, so DIE DIE DIE.  
        r.configChangeFlags |= changes;  
        r.startFreezingScreenLocked(r.app, globalChanges);  
        r.forceNewConfig = false;  
        preserveWindow &amp;= isResizeOnlyChange(changes);  
        if (r.app == null || r.app.thread == null) {  
            ......  
        } else if (r.state == ActivityState.RESUMED) {  
            // Try to optimize this case: the configuration is changing and we need to restart  
            // the top, resumed activity. Instead of doing the normal handshaking, just say  
            // &quot;restart!&quot;.  
            relaunchActivityLocked(r, r.configChangeFlags, true, preserveWindow);  
        } else {  
            if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,  
                    &quot;Config is relaunching non-resumed &quot; + r);  
            relaunchActivityLocked(r, r.configChangeFlags, false, preserveWindow);  
        }  

        // All done...  tell the caller we weren&apos;t able to keep this activity around.  
        return false;  
    }  

    // Default case: the activity can handle this new configuration, so hand it over.  
    // NOTE: We only forward the task override configuration as the system level configuration  
    // changes is always sent to all processes when they happen so it can just use whatever  
    // system level configuration it last got.  
    r.scheduleConfigurationChanged(taskConfig, true);  
    r.stopFreezingScreenLocked(false);  

    return true;  
}  </code></pre><p>上面代码第5行是这个方法重要的分支点。<br>首先我们假设此时的activity设置了configChanges=”orientation|screenSize”。<br>如果此时config只发生了旋屏变化，此时<code>changes&amp;(~r.info.getRealConfigChanged())</code>为0，整个判断条件为false(标记位的细节就不解释了)，所以会跳过该代码块，走下面28行开始的schedule流程，也就是onConfigurationChanged流程；<br>相对的，如果此时的config发生了其它变化，或者不只是旋屏变化，此时判断条件会为真，意味着app无法在onCOnfigurationChanged自行处理config的所有变化，需要重走实例化流程，走relaunch流程并返回。<br>这段代码基本解释了为什么有的时候应用不得不重新实例化，有的时候则是走onConfigurationChanged。  </p>
<p>还有一点要提一下，<strong>relaunch和onConfigurationChanged流程是不会并存的</strong>。<br>虽然ensureActivityConfig之前都会发出scheduleConfigurationChanged流程，但在app一侧，也会进行上面类似的判断，对与activityinfo.getRealConfigChanged()掩码不能handle当前config变化的情况，会跳过onConfigurationChanged，果断等待后面的relaunch。<br><strong>android.app.ActivityThread#performConfigurationChanged</strong>  </p>
<pre><code>private void performConfigurationChanged(ComponentCallbacks2 cb,  
                                             IBinder activityToken,  
                                             Configuration newConfig,  
                                             Configuration amOverrideConfig,  
                                             boolean reportToActivity) {  
        ......  
        boolean shouldChangeConfig = false;  
        if ((activity == null) || (activity.mCurrentConfig == null)) {  
            shouldChangeConfig = true;  
        } else {  
            // If the new config is the same as the config this Activity is already  
            // running with and the override config also didn&apos;t change, then don&apos;t  
            // bother calling onConfigurationChanged.  
            int diff = activity.mCurrentConfig.diff(newConfig);  
            if (diff != 0 || !mResourcesManager.isSameResourcesOverrideConfig(activityToken,  
                    amOverrideConfig)) {  
                // Always send the task-level config changes. For system-level configuration, if  
                // this activity doesn&apos;t handle any of the config changes, then don&apos;t bother  
                // calling onConfigurationChanged as we&apos;re going to destroy it.  
                if (!mUpdatingSystemConfig  
                        || (~activity.mActivityInfo.getRealConfigChanged() &amp; diff) == 0  
                        || !reportToActivity) {  
                    shouldChangeConfig = true;  
                }  
            }  
        }  

        if (shouldChangeConfig) {  
            ...  
            if (reportToActivity) {  
                cb.onConfigurationChanged(configToReport);  
            }  
            ...  
        }  </code></pre><p>如上，在21行会同样把ActivityInfo.getRealConfigChanged与diff做判断，如果shouldChangeConfig不为真，后面并不会调用onConfigurationChanged。  </p>
<p>也就是说，我们任何写在onConfiguraionChanged中的一套东西，不能忘了在实例化时也得有一套（如果在旋转屏幕的同时还发生了其它的配置变化，并不会先在onConfigChange里处理屏幕旋转）。  </p>
<h3 id="6-2-需要实例化的情况，做好现场的保存与恢复"><a href="#6-2-需要实例化的情况，做好现场的保存与恢复" class="headerlink" title="6.2 需要实例化的情况，做好现场的保存与恢复"></a>6.2 需要实例化的情况，做好现场的保存与恢复</h3><p>由于应用侧代码写得较少，我自己这里也总结不出什么好的具体实践的建议，这里暂时就贴下我看到的比较好的总结以及官方文档，以后有机会再更新。<br><a href="https://developer.android.com/guide/topics/resources/runtime-changes.html?hl=zh-cn#RetainingAnObject" target="_blank" rel="noopener">在配置变更期间保留对象</a><br><a href="http://code.hootsuite.com/orientation-changes-on-android/" target="_blank" rel="noopener">Handling Orientation Changes on Android</a><br><a href="http://www.jianshu.com/p/0b5403c42fdb" target="_blank" rel="noopener">保存与恢复</a>  </p>
<h2 id="7-DividerBar-分屏分割条如何在旋转时附加特殊动画"><a href="#7-DividerBar-分屏分割条如何在旋转时附加特殊动画" class="headerlink" title="7 DividerBar 分屏分割条如何在旋转时附加特殊动画"></a>7 DividerBar 分屏分割条如何在旋转时附加特殊动画</h2><p>  (未完待续)</p>
<hr>
<p><strong>注</strong>:</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">LocalActivityManager#moveToState(INITIALIZING)-&gt;startActivityNow() 和 handleLaunch() 都会走到performLaunchActivity() -&gt; onStart() -&gt; onCreate()<br>

<p><a href="http://or5nesfx1.bkt.clouddn.com/prief_force_orientation_flow.png" target="_blank" rel="noopener">8</a>: <a href="http://or5nesfx1.bkt.clouddn.com/prief_force_orientation_flow.png" target="_blank" rel="noopener">http://or5nesfx1.bkt.clouddn.com/prief_force_orientation_flow.png</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://benzblog.site/2017-06-16-tasks-differences-between-ams-and-recnets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://benzgallery.oss-cn-shanghai.aliyuncs.com/sailing_cat 1200.png">
      <meta itemprop="name" content="BenZ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔哲明的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-06-16-tasks-differences-between-ams-and-recnets/" class="post-title-link" itemprop="url">Recents和AMS中历史任务的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-16 00:00:00" itemprop="dateCreated datePublished" datetime="2017-06-16T00:00:00+08:00">2017-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-07-04 21:42:48" itemprop="dateModified" datetime="2019-07-04T21:42:48+08:00">2019-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tech/" itemprop="url" rel="index"><span itemprop="name">Tech</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017-06-16-tasks-differences-between-ams-and-recnets/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017-06-16-tasks-differences-between-ams-and-recnets/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            
            <div class="post-tags" style="margin:5px">
                <a href="/tags/Android/" rel="tag"><i class="fa fa-tag"></i> Android</a>
                <a href="/tags/Frameworks/" rel="tag"><i class="fa fa-tag"></i> Frameworks</a>
                <a href="/tags/AMS/" rel="tag"><i class="fa fa-tag"></i> AMS</a>
            </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><img data-src="http://or5nesfx1.bkt.clouddn.com/%E4%BB%BB%E5%8A%A1%E6%A0%88_%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="任务历史保存方式关系图"><br>图中左上部分是任务历史在AMS中保存的列表，右上部分是多任务界面里所会展示的任务列表，左下则是实际上还在前后台运行的task列表，可以看到，这三者是有不小区别的，并不是同步的。<br>下面讲首先分别讲下它们三者负责什么、意义所在，然后通过一些具体方法的使用看下它们之间的关系。  </p>
<h3 id="1-1-任务和返回栈-实际数据模型-左下"><a href="#1-1-任务和返回栈-实际数据模型-左下" class="headerlink" title="1.1 任务和返回栈 - 实际数据模型   (左下)"></a>1.1 任务和返回栈 - 实际数据模型   (左下)</h3><p>这个是指在调度体系里实际保存的TaskRecord实例，而ActivityRecord-TaskRecord-ActivityStack之间的关系建议看<a href="https://developer.android.com/guide/components/tasks-and-back-stack.html" target="_blank" rel="noopener">官方文档</a>。<br>任务栈是实际在后台的任务，因此这些任务也都有对应的显示层实例。  </p>
<p>其创建与删除通过stack控制： ActivityStack#createTaskRecord()，ActivityStack#removeTask()<br>当前activity栈可以通过adb shell dumpsys activity activities 命令打印出来，这个命令最终会调用到方法：<br>AMS#dumpActivitiesLocked() -&gt; ActivityStackSupervisor#dumpActivitiesLocked()  </p>
<h3 id="1-2-AMS-mRecentTasks-历史任务记录（左上）"><a href="#1-2-AMS-mRecentTasks-历史任务记录（左上）" class="headerlink" title="1.2 AMS.mRecentTasks - 历史任务记录（左上）"></a>1.2 AMS.mRecentTasks - 历史任务记录（左上）</h3><p><code>RecentTasks</code>用于在AMS中保存最近使用的task记录，可以通过adb shell dumpsys activity recents命令打印其列表。  </p>
<p><code>RecentTasks</code>应该被看作任务的历史记录而不是实例，虽然保留了TaskRecord对象，但并不一定有对应的activity。  </p>
<p><code>RecentTasks</code>列表是始终有序的，最近使用的task在列表中的位置最靠前。之所以有序，是因为框架里，每次resume后都会把当前应用重新添加到RecentTasks中，典型代码如下：  </p>
<pre><code class="Java">ActivityStack#resumeTopActivityInnerLocked() {  
            ......  
            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES, <span class="string">"Moving to RESUMED: "</span> + next + <span class="string">" (in existing)"</span>);  
            next.state = ActivityState.RESUMED;  
            mResumedActivity = next;  
            next.task.touchActiveTime();  
            mRecentTasks.addLocked(next.task);  
            mService.updateLruProcessLocked(next.app, <span class="keyword">true</span>, <span class="keyword">null</span>);  
            updateLRUListLocked(next);  
            mService.updateOomAdjLocked();  
            ......  
}  </code></pre>
<p>如上代码第7行即将task置于mRecentTasks头部，而6行是更新task的activeTime。  </p>
<p>与add对应的remove，则基本只有AMS#cleanUpRemovedTaskLocked()这一个地方：  </p>
<pre><code class="Java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanUpRemovedTaskLocked</span><span class="params">(TaskRecord tr, <span class="keyword">boolean</span> killProcess,  </span></span>
<span class="function"><span class="params">            <span class="keyword">boolean</span> removeFromRecents)</span> </span>{  
        <span class="keyword">if</span> (removeFromRecents) {  
            mRecentTasks.remove(tr);  
            tr.removedFromRecents();  
            <span class="comment">// zeusis : clear the paired TaskRecord and resize fullscreenStack to normal  </span>
            ......  
        }  
        .....  
    }  </code></pre>
<p>通常的remove途径，就是用户在多任务上滑快照回收一个应用或在多任务点清理内存按钮批量回收应用。<br>应用按back键退出做finish，虽然activity都destroy掉了，在整个的应用栈里被删掉，但是taskrecord其实还是保留下来的，保存在mRecentTasks中直到历史记录过多<sup id="fnref:1"><a href="#fn:1" rel="footnote">&lt;span class=”hint–top hint–error hint–medium hint–rounded hint–bounce” aria-label=”如果应用历史记录数超过设定的MAX值(48)，会将RecentTasks表末的记录删掉，详见AMS#addAppTask(). L10731  </p>
<p>[^reboot_restore]:重启后persistent的应用taskRecord会在RecentTasks中重新生成。  “&gt;<a href="http://or5nesfx1.bkt.clouddn.com/%E4%BB%BB%E5%8A%A1%E6%A0%88_%E5%85%B3%E7%B3%BB%E5%9B%BE.png" target="_blank" rel="noopener">1</a></span></a></sup>或重启<sup id="fnref:1"><a href="#fn:1" rel="footnote">&lt;span class=”hint–top hint–error hint–medium hint–rounded hint–bounce” aria-label=”如果应用历史记录数超过设定的MAX值(48)，会将RecentTasks表末的记录删掉，详见AMS#addAppTask(). L10731  </p>
<p>[^reboot_restore]:重启后persistent的应用taskRecord会在RecentTasks中重新生成。  “&gt;<a href="http://or5nesfx1.bkt.clouddn.com/%E4%BB%BB%E5%8A%A1%E6%A0%88_%E5%85%B3%E7%B3%BB%E5%9B%BE.png" target="_blank" rel="noopener">1</a></span></a></sup>才可能销毁。  </p>
<p>####TaskPersister<br>与RecentTasks相关的还有TaskPersister，用于保存被设定persistent属性的任务列表，并在手机重启后从本地保存的xml重新加载TaskRecord。有兴趣的话可以看TaskRecord#restoreFromXml()及相关流程。  </p>
<h3 id="1-3-多任务-展示给用户的任务概览（右上）"><a href="#1-3-多任务-展示给用户的任务概览（右上）" class="headerlink" title="1.3 多任务 - 展示给用户的任务概览（右上）"></a>1.3 多任务 - 展示给用户的任务概览（右上）</h3><p>Recents(多任务)中记录的任务列表与其它两者是不一样的，由于是展示给用户的，所以要尽可能符合用户期待,这就造成一些实际已销毁或回收的任务也要保存显示，而一些无关紧要的或特别的应用又需要隐藏起来。  </p>
<p>如此说来，这个任务列表首先就是与任务栈解耦的，实际上，多任务的列表是每次启动多任务时从任务历史记录处获取列表，然后再做各种过滤动作获得真正适合展示给用户的列表。在下文3.1节具体讲解了多任务的列表是如何从AMS获取并过滤的。  </p>
<p>[Recents官方文档][3]  </p>
<h2 id="2-关系"><a href="#2-关系" class="headerlink" title="2 关系"></a>2 关系</h2><h3 id="AMS-RecentTasks和SystemUI-Recents-TaskStack区别"><a href="#AMS-RecentTasks和SystemUI-Recents-TaskStack区别" class="headerlink" title="AMS#RecentTasks和SystemUI.Recents.TaskStack区别"></a>AMS#RecentTasks和SystemUI.Recents.TaskStack区别</h3><ul>
<li>两者数据形式上都是线性有序的  </li>
<li>后者列表包含于前者，后者是前者过滤而来的，具体过滤步骤见3.1的流程  </li>
<li>前者的更新会触发回调改变后者  </li>
</ul>
<h3 id="AMS-RecentTasks和任务栈区别"><a href="#AMS-RecentTasks和任务栈区别" class="headerlink" title="AMS#RecentTasks和任务栈区别"></a>AMS#RecentTasks和任务栈区别</h3><ul>
<li>任务栈是个大的数据模型，taskRecord按序排列在不同栈中，而RecentTasks是线性记录  </li>
<li>应用destory后，在RecentTasks中仍保有其taskrecord，但在任务栈中已将其移除  </li>
</ul>
<h2 id="3-具体代码例子"><a href="#3-具体代码例子" class="headerlink" title="3 具体代码例子"></a>3 具体代码例子</h2><h3 id="3-1-Recents从AMS-RecentTasks更新列表"><a href="#3-1-Recents从AMS-RecentTasks更新列表" class="headerlink" title="3.1 Recents从AMS.RecentTasks更新列表"></a>3.1 Recents从AMS.RecentTasks更新列表</h3><p>Recents作为系统界面，虽然与AMS关系紧密，但毕竟是一个独立出来的app模块，所以其列表很难做到与server一侧的情况保持同步，为此，Recents每次启动时都要重刷整个列表，确保符合现场。重刷列表是比较费时的操作，故此，AOSP将Recents设计启动前先做预处理，从server一侧获取列表并作大致过滤，然后启动recentsActivity。  </p>
<p>多任务界面的启动通过PhoneStatusBar.showRecentApps方法，在向AMS发起启动activity请求前，会先preload，一个典型的多任务界面启动时调用栈如下：  </p>
<blockquote>
<p>at com.android.systemui.recents.model.RecentsTaskLoadPlan.preloadRawTasks(RecentsTaskLoadPlan.java:125)<br>at com.android.systemui.recents.model.RecentsTaskLoadPlan.preloadPlan(RecentsTaskLoadPlan.java:153)<br>at com.android.systemui.recents.model.RecentsTaskLoader.preloadTasks(RecentsTaskLoader.java:384)<br>at com.android.systemui.recents.RecentsImpl.startRecentsActivity(RecentsImpl.java:924)<br>at com.android.systemui.recents.RecentsImpl.showRecents(RecentsImpl.java:316)<br>at com.android.systemui.recents.Recents.showRecents(Recents.java:308)  </p>
</blockquote>
<p>通过以下两层方法从AMS获得rawTasks列表SystemServiceProxy#getRecentTasks() -&gt; AMS#getRecentTasks()。<br>这是最先的两层过滤，AMS一侧的方法用来获取最近符合要求应用列表，而SSP的方法是在调用前者后再根据多任务另外设置的黑名单再过滤一遍。  </p>
<p>我们先看AMS一侧的代码。  </p>
<h4 id="3-1-1-第一层过滤"><a href="#3-1-1-第一层过滤" class="headerlink" title="3.1.1 第一层过滤"></a>3.1.1 第一层过滤</h4><p><strong>AMS#getRecentTasks()</strong>  </p>
<pre><code class="Java"><span class="meta">@Override</span>  
<span class="keyword">public</span> ParceledListSlice&lt;ActivityManager.RecentTaskInfo&gt; getRecentTasks(<span class="keyword">int</span> maxNum, <span class="keyword">int</span> flags,  
        <span class="keyword">int</span> userId) {  
    <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();  
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), callingUid, userId,  
            <span class="keyword">false</span>, ALLOW_FULL_ONLY, <span class="string">"getRecentTasks"</span>, <span class="keyword">null</span>);  

    <span class="keyword">final</span> <span class="keyword">boolean</span> includeProfiles = (flags &amp; ActivityManager.RECENT_INCLUDE_PROFILES) != <span class="number">0</span>;  
    <span class="keyword">final</span> <span class="keyword">boolean</span> withExcluded = (flags&amp;ActivityManager.RECENT_WITH_EXCLUDED) != <span class="number">0</span>;  
    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {  
        <span class="keyword">final</span> <span class="keyword">boolean</span> allowed = isGetTasksAllowed(<span class="string">"getRecentTasks"</span>, Binder.getCallingPid(),  
                callingUid);  
        <span class="keyword">final</span> <span class="keyword">boolean</span> detailed = checkCallingPermission(  
                android.Manifest.permission.GET_DETAILED_TASKS)  
                == PackageManager.PERMISSION_GRANTED;  

        <span class="keyword">if</span> (!isUserRunning(userId, ActivityManager.FLAG_AND_UNLOCKED)) {  
            Slog.i(TAG, <span class="string">"user "</span> + userId + <span class="string">" is still locked. Cannot load recents"</span>);  
            <span class="keyword">return</span> ParceledListSlice.emptyList();  
        }  
        mRecentTasks.loadUserRecentsLocked(userId);  

        <span class="keyword">final</span> <span class="keyword">int</span> recentsCount = mRecentTasks.size();  
        ArrayList&lt;ActivityManager.RecentTaskInfo&gt; res =  
                <span class="keyword">new</span> ArrayList&lt;&gt;(maxNum &lt; recentsCount ? maxNum : recentsCount);  

        <span class="keyword">final</span> Set&lt;Integer&gt; includedUsers;  
        <span class="keyword">if</span> (includeProfiles) {  
            includedUsers = mUserController.getProfileIds(userId);  
        } <span class="keyword">else</span> {  
            includedUsers = <span class="keyword">new</span> HashSet&lt;&gt;();  
        }  
        includedUsers.add(Integer.valueOf(userId));  

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; recentsCount &amp;&amp; maxNum &gt; <span class="number">0</span>; i++) {  
            TaskRecord tr = mRecentTasks.get(i);  
            <span class="comment">// Only add calling user or related users recent tasks   </span>
            <span class="keyword">if</span> (!includedUsers.contains(Integer.valueOf(tr.userId))) {  
                <span class="keyword">if</span> (DEBUG_RECENTS) Slog.d(TAG_RECENTS, <span class="string">"Skipping, not user: "</span> + tr);  
                <span class="keyword">continue</span>;<span class="comment">//不属于该用户组的跳过  </span>
            }  

            <span class="keyword">if</span> (tr.realActivitySuspended) {  
                <span class="keyword">if</span> (DEBUG_RECENTS) Slog.d(TAG_RECENTS, <span class="string">"Skipping, activity suspended: "</span> + tr);  
                <span class="keyword">continue</span>;  
            }  

            <span class="comment">// Return the entry if desired by the caller.  We always return  </span>
            <span class="comment">// the first entry, because callers always expect this to be the  </span>
            <span class="comment">// foreground app.  We may filter others if the caller has  </span>
            <span class="comment">// not supplied RECENT_WITH_EXCLUDED and there is some reason  </span>
            <span class="comment">// we should exclude the entry.  </span>

            <span class="keyword">if</span> (i == <span class="number">0</span>  
                    || withExcluded  
                    || (tr.intent == <span class="keyword">null</span>)  
                    || ((tr.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)  
                            == <span class="number">0</span>)) {  
                <span class="keyword">if</span> (!allowed) {  
                    <span class="comment">// If the caller doesn't have the GET_TASKS permission, then only  </span>
                    <span class="comment">// allow them to see a small subset of tasks -- their own and home.  </span>
                    <span class="keyword">if</span> (!tr.isHomeTask() &amp;&amp; tr.effectiveUid != callingUid) {  
                        <span class="keyword">if</span> (DEBUG_RECENTS) Slog.d(TAG_RECENTS, <span class="string">"Skipping, not allowed: "</span> + tr);  
                        <span class="keyword">continue</span>;<span class="comment">//没有GET_TASKS权限的不能获取其它应用的列表  </span>
                    }  
                }  

                <span class="keyword">if</span> ((flags &amp; ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS) != <span class="number">0</span>) {  
                    <span class="keyword">if</span> (tr.stack != <span class="keyword">null</span> &amp;&amp; tr.stack.isHomeStack()) {  
                        <span class="keyword">if</span> (DEBUG_RECENTS) Slog.d(TAG_RECENTS,  
                                <span class="string">"Skipping, home stack task: "</span> + tr);  
                        <span class="keyword">continue</span>;  
                    }  
                }  
                <span class="keyword">if</span> ((flags &amp; ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK) != <span class="number">0</span>) {  
                    <span class="keyword">final</span> ActivityStack stack = tr.stack;  
                    <span class="keyword">if</span> (stack != <span class="keyword">null</span> &amp;&amp; stack.isDockedStack() &amp;&amp; stack.topTask() == tr) {  
                        <span class="keyword">if</span> (DEBUG_RECENTS) Slog.d(TAG_RECENTS,  
                                <span class="string">"Skipping, top task in docked stack: "</span> + tr);  
                        <span class="keyword">continue</span>;<span class="comment">//原生逻辑，在A/r状态下，下屏miniRecents中不会有上屏应用的快照  </span>
                    }  
                }  
                <span class="keyword">if</span> ((flags &amp; ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS) != <span class="number">0</span>) {  
                    <span class="keyword">if</span> (tr.stack != <span class="keyword">null</span> &amp;&amp; tr.stack.isPinnedStack()) {  
                        <span class="keyword">if</span> (DEBUG_RECENTS) Slog.d(TAG_RECENTS,  
                                <span class="string">"Skipping, pinned stack task: "</span> + tr);  
                        <span class="keyword">continue</span>;  
                    }  
                }  
                <span class="keyword">if</span> (tr.autoRemoveRecents &amp;&amp; tr.getTopActivity() == <span class="keyword">null</span>) {  
                    <span class="comment">// Don't include auto remove tasks that are finished or finishing.  </span>
                    <span class="keyword">if</span> (DEBUG_RECENTS) Slog.d(TAG_RECENTS,  
                            <span class="string">"Skipping, auto-remove without activity: "</span> + tr);  
                    <span class="keyword">continue</span>;<span class="comment">//autoRemoveRecents的应用在销毁后会从mRecentsTasks列表中删除，这种情况只是还没来得及删除，但也要过滤掉  </span>
                }  
                <span class="keyword">if</span> ((flags&amp;ActivityManager.RECENT_IGNORE_UNAVAILABLE) != <span class="number">0</span>  
                        &amp;&amp; !tr.isAvailable) {  
                    <span class="keyword">if</span> (DEBUG_RECENTS) Slog.d(TAG_RECENTS,  
                            <span class="string">"Skipping, unavail real act: "</span> + tr);  
                    <span class="keyword">continue</span>;  
                }  

                <span class="keyword">if</span> (!tr.mUserSetupComplete) {  
                    <span class="comment">// Don't include task launched while user is not done setting-up.  </span>
                    <span class="keyword">if</span> (DEBUG_RECENTS) Slog.d(TAG_RECENTS,  
                            <span class="string">"Skipping, user setup not complete: "</span> + tr);  
                    String record = tr.toString();  
                    <span class="keyword">if</span>(record.contains(QQ_NAME) || record.contains(WEIBO_NAME) || record.contains(WECHAT_NAME)){  
                        <span class="keyword">if</span> (DEBUG_RECENTS) Slog.d(TAG_RECENTS,<span class="string">"not skip for dualapp"</span> + tr);  
                    }<span class="keyword">else</span>{  
                        <span class="keyword">continue</span>;  
                    }  
                }  

                ActivityManager.RecentTaskInfo rti = createRecentTaskInfoFromTaskRecord(tr);  
                <span class="keyword">if</span> (!detailed) {  
                    rti.baseIntent.replaceExtras((Bundle)<span class="keyword">null</span>);  
                }  

                res.add(rti);  
                maxNum--;  
            }  
        }  
        <span class="keyword">return</span> <span class="keyword">new</span> ParceledListSlice&lt;&gt;(res);  
    }  
}  </code></pre>
<p>这个方法看起来比较长，但逻辑其实很简单。<br>首先从入参看，maxNum是所需的列表长度，满足数量即返回。flag是过滤条件。userId用于过滤掉不属于该应用组的应用。<br>从35行开始，遍历任务历史记录mRecentTasks，根据方法入参携带的flag做相应过滤，不符合要求的跳过，符合要求的则增加到结果列表，直到结果数目符合要求，结束遍历返回结果。  </p>
<p>54~60行的逻辑主要针对EXCLUDE_FROM_RECENTS这个标记位。EXCLUDE_FROM_RECENTS，顾名思义，在Recents中不显示，多任务获取列表时，flag不会带有RECENT_WITH_EXCLUDED标识，withExcluded为false，此时应用如果设置了EXCLUDE_FROM_RECENTS就会被跳过不作为结果返回，不过有个<span id= "exclude_fail_case">特例</span>，表头的应用不受此限制，就是说，从应用A进入多任务仍会有A的快照，也正因此，在SSP中需要另外增加黑名单逻辑对一些特殊的应用再做一次过滤。  </p>
<p>60行之后的代码是针对flag中每一个过滤需求跳过相应task。  </p>
<p><s>67~99行是在处理分屏问题过程中我们增加的一些过滤机制，相对应的也增加了各种flag。之所以在这里加过滤机制，是因为许多地方要判断当前后台运行的应用是否支持分屏之类的，这就一定要通过getRecent获取最近任务列表，而多任务的列表有其自己一套过滤机制，且与后台并不完全同步，不能直接拿来用，因此我们只好模仿着增加特别分屏需要的过滤。  </s></p>
<p>从AMS一侧获取列表后，还要继续在ssp的方法中筛掉黑名单里的应用。  </p>
<h4 id="3-1-2-第二层过滤"><a href="#3-1-2-第二层过滤" class="headerlink" title="3.1.2 第二层过滤"></a>3.1.2 第二层过滤</h4><p><strong>SystemServiceProxy#getRecentTasks()</strong>  </p>
<pre><code class="Java"><span class="keyword">public</span> List&lt;ActivityManager.RecentTaskInfo&gt; getRecentTasks(<span class="keyword">int</span> numLatestTasks, <span class="keyword">int</span> userId,  
        <span class="keyword">boolean</span> includeFrontMostExcludedTask, ArraySet&lt;Integer&gt; quietProfileIds) {  
    ......  

    <span class="comment">// Remove home/recents/excluded tasks  </span>
    <span class="keyword">int</span> minNumTasksToQuery = <span class="number">10</span>;  
    <span class="keyword">int</span> numTasksToQuery = Math.max(minNumTasksToQuery, numLatestTasks);  
    <span class="keyword">int</span> flags = ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS |  
            <span class="comment">//ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK |  </span>
            ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS |  
            ActivityManager.RECENT_IGNORE_UNAVAILABLE |  
            ActivityManager.RECENT_INCLUDE_PROFILES;  
    <span class="keyword">if</span>(mIsInMultiWindowMode == <span class="keyword">true</span>) {  
        flags |= ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK;  
    }  
    <span class="keyword">if</span> (includeFrontMostExcludedTask) {  
        flags |= ActivityManager.RECENT_WITH_EXCLUDED;  
    }  
    List&lt;ActivityManager.RecentTaskInfo&gt; tasks = <span class="keyword">null</span>;  
    <span class="keyword">try</span> {  
        tasks = mAm.getRecentTasksForUser(numTasksToQuery, flags, userId);  
    } <span class="keyword">catch</span> (Exception e) {  
        Log.e(TAG, <span class="string">"Failed to get recent tasks"</span>, e);  
    }  

    <span class="comment">// Break early if we can't get a valid set of tasks  </span>
    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>) {  
        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();  
    }  

    <span class="keyword">boolean</span> isFirstValidTask = <span class="keyword">true</span>;  
    Iterator&lt;ActivityManager.RecentTaskInfo&gt; iter = tasks.iterator();  
    <span class="keyword">while</span> (iter.hasNext()) {  
        ActivityManager.RecentTaskInfo t = iter.next();  

        <span class="comment">// <span class="doctag">NOTE:</span> The order of these checks happens in the expected order of the traversal of the  </span>
        <span class="comment">// tasks  </span>

        <span class="comment">// Remove the task if it or it's package are blacklsited  </span>
        <span class="keyword">if</span> (sRecentsBlacklist.contains(t.realActivity.getClassName()) ||  
                sRecentsBlacklist.contains(t.realActivity.getPackageName())) {  
            iter.remove();  
            <span class="keyword">continue</span>;  
        }  
        ......  
    }  

    <span class="keyword">return</span> tasks.subList(<span class="number">0</span>, Math.min(tasks.size(), numLatestTasks));  
}  </code></pre>
<p>8~12行是多任务从AMS获取列表的默认flag。  </p>
<p>上述代码中的21行从AMS获得列表，然后在40~44行里，将黑名单中的去掉。  </p>
<p>上文提到，某些<a href="#exclude_fail_case">特例</a>下，设置了从多任务排除掉的应用仍会在多任务显示，像这种无论如何都不希望在多任务显示的应用，可以在此处加入黑名单，就能够确保从列表中去掉了。  </p>
<p>除了这些基本的过滤，Recents还有进行自己的一套过滤，比如说丢弃掉已经太久没有激活过的应用。  </p>
<h4 id="3-1-3-第三层过滤"><a href="#3-1-3-第三层过滤" class="headerlink" title="3.1.3 第三层过滤"></a>3.1.3 第三层过滤</h4><p>在RecentsTaskLoadPlan#preloadPlan中，上述的preloadRawTasks()执行完后，还会遍历得到的mRawTasks做深一步的预处理和过滤。<br>其中有个判定项<code>isStackTask</code>将会在后面用作过滤。  </p>
<pre><code class="Java"><span class="keyword">boolean</span> isStackTask = isFreeformTask || !isHistoricalTask(t) ||  
        (t.lastActiveTime &gt;= lastStackActiveTime &amp;&amp; i &gt;= (taskCount - MIN_NUM_TASKS));  

<span class="comment">/**  </span>
<span class="comment"> * Returns whether this task is too old to be shown.  </span>
<span class="comment"> */</span>  
<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isHistoricalTask</span><span class="params">(ActivityManager.RecentTaskInfo t)</span> </span>{  
    <span class="keyword">return</span> t.lastActiveTime &lt; (System.currentTimeMillis() - SESSION_BEGIN_TIME <span class="comment">/* 6h */</span>);  
}  </code></pre>
<p>如上代码，如果应用有太久没有使用，isHistoricalTask将会为true，isStackTask将可能为false(后面一个条件具体解释起来比较复杂，有兴趣的可以继续阅读源码相关部分思考其用处)。  </p>
<p>在随后的处理中，mRawTasks会继续被处理成FilteredTaskList：<code>mStackTaskList</code>，并根据acceptTask()接口返回的值决定是否保留在FilterdTaskList。  </p>
<blockquote>
<p>at com.android.systemui.recents.model.TaskStack$2.acceptTask(TaskStack.java:608)<br>at com.android.systemui.recents.model.FilteredTaskList.updateFilteredTasks(TaskStack.java:204)<br>at com.android.systemui.recents.model.FilteredTaskList.set(TaskStack.java:159)<br>at com.android.systemui.recents.model.TaskStack.setTasks(TaskStack.java:851)<br>at com.android.systemui.recents.model.RecentsTaskLoadPlan.preloadPlan(RecentsTaskLoadPlan.java:228)<br>at com.android.systemui.recents.model.RecentsTaskLoader.preloadTasks(RecentsTaskLoader.java:384)  </p>
</blockquote>
<pre><code class="Java"><span class="function"><span class="keyword">public</span> <span class="title">TaskStack</span><span class="params">()</span> </span>{  
        <span class="comment">// Ensure that we only show non-docked tasks  </span>
        mStackTaskList.setFilter(<span class="keyword">new</span> TaskFilter() {  
            <span class="meta">@Override</span>  
            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptTask</span><span class="params">(SparseArray&lt;Task&gt; taskIdMap, Task t, <span class="keyword">int</span> index)</span> </span>{  
                <span class="keyword">if</span> (RecentsDebugFlags.Static.EnableAffiliatedTaskGroups) {  
                    <span class="keyword">if</span> (t.isAffiliatedTask()) {  
                        <span class="comment">// If this task is affiliated with another parent in the stack, then the  </span>
                        <span class="comment">// historical state of this task depends on the state of the parent task  </span>
                        Task parentTask = taskIdMap.get(t.affiliationTaskId);  
                        <span class="keyword">if</span> (parentTask != <span class="keyword">null</span>) {  
                            t = parentTask;  
                        }  
                    }  
                }  
                <span class="keyword">return</span> t.isStackTask;  
            }  
        });  
    }  </code></pre>
<p>如上代码中16行，如果之前计算得出的isStackTask为false，那就会被过滤掉。<code>mStackTaskList</code>才是最后在多任务中被拿来用的任务列表。  </p>
<h3 id="3-2-应用如何设定自己不在多任务中显示"><a href="#3-2-应用如何设定自己不在多任务中显示" class="headerlink" title="3.2 应用如何设定自己不在多任务中显示"></a>3.2 应用如何设定自己不在多任务中显示</h3><p>首先要增加EXCLUDE_FROM_RECENTS属性，具体来说，在模块manifest中的<Activity>里增加如下代码  </p>
<pre><code class="xml"><span class="tag">&lt;<span class="name">activity</span>  </span>
<span class="tag">  <span class="attr">android:name</span>=<span class="string">"XYZ"</span>  </span>
<span class="tag">  <span class="attr">android:excludeFromRecents</span>=<span class="string">"true"</span>&gt;</span>  </code></pre>
<p>但原生逻辑下，从应用直接进入多任务的时候，及时加了exclude属性，当前应用的快照也会保留，如果这种情况也不希望显示。那么需要将自己加入多任务黑名单。<br><strong>SystemServiceProxy.sRecentsBlacklist:</strong>  </p>
<pre><code>final static List&lt;String&gt; sRecentsBlacklist;  
static {  
    sRecentsBlacklist = new ArrayList&lt;&gt;();  
    sRecentsBlacklist.add(&quot;com.android.systemui.tv.pip.PipOnboardingActivity&quot;);  
    sRecentsBlacklist.add(&quot;com.android.systemui.tv.pip.PipMenuActivity&quot;);  
}  </code></pre><p><s>上面是我们ROM里当前的黑名单，头两个是原生就有的，后面是针对JUI系统界面需求所增加的，像全局搜索、bigbang这类的，对用户算是系统界面的一部分，但实际上却是通过app实现的应用适合加入黑名单。  </s></p>
<h3 id="3-3-如何获取后台应用列表而不是历史记录"><a href="#3-3-如何获取后台应用列表而不是历史记录" class="headerlink" title="3.3 如何获取后台应用列表而不是历史记录"></a>3.3 如何获取后台应用列表而不是历史记录</h3><p>前面一直讲的getRecentTasks()获取的列表包含了已经处于destoryed状态的tasks，如果只想要后台运行应用的列表，可以使用mAm.getRunningTasks(maxNum)方法，这个方法会调用到AMS#getTasks():  </p>
<pre><code>@Override  
    public List&lt;RunningTaskInfo&gt; getTasks(int maxNum, int flags) {  
        final int callingUid = Binder.getCallingUid();  
        ArrayList&lt;RunningTaskInfo&gt; list = new ArrayList&lt;RunningTaskInfo&gt;();  
        synchronized(this) {  
            final boolean allowed = isGetTasksAllowed(&quot;getTasks&quot;, Binder.getCallingPid(),  
                    callingUid);  

            // TODO: Improve with MRU list from all ActivityStacks.  
            mStackSupervisor.getTasksLocked(maxNum, list, callingUid, allowed);  
        }  
        return list;  
    }  </code></pre><p>StackSuperVisor#getTasksLocked()方法会深搜遍历activity任务栈，然后截取所需数目的列表并返回。<br>不过mAm.getRunningTasks()这个方法已经是@Deprecated的了。<br>我们看到第9行有个TODO，但这个已经好几年没有变化了，大概是RecentTasks已经基本够用了。  </p>
<h3 id="3-2-mRecentTasks中的taskRecord重回任务栈舞台"><a href="#3-2-mRecentTasks中的taskRecord重回任务栈舞台" class="headerlink" title="3.2 mRecentTasks中的taskRecord重回任务栈舞台"></a>3.2 mRecentTasks中的taskRecord重回任务栈舞台</h3><p>从多任务点击快照与一般启动应用的方式不一样。一般从Launcher启动或是应用间跳转都是借助Intent，在新建task之前，会遍历任务栈中的应用看是否有intent相同的task并复用之。<br>而从多任务启动应用，却与intent无关，是直接使用taskId的：<br><strong>ASS#startActivityFromRecentsInner</strong>  </p>
<pre><code class="Java"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityFromRecentsInner</span><span class="params">(<span class="keyword">int</span> taskId, Bundle bOptions)</span> </span>{  
    ......  
    task = anyTaskForIdLocked(taskId, RESTORE_FROM_RECENTS, launchStackId);  
    <span class="keyword">if</span> (task == <span class="keyword">null</span>) {  
        continueUpdateBounds(HOME_STACK_ID);  
        mWindowManager.executeAppTransition();  
        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(  
                <span class="string">"startActivityFromRecentsInner: Task "</span> + taskId + <span class="string">" not found."</span>);  
    }  
    ......  
}  </code></pre>
<p><strong>ASS#anyTaskForIdLocked</strong>  </p>
<pre><code class="Java"><span class="function">TaskRecord <span class="title">anyTaskForIdLocked</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">boolean</span> restoreFromRecents, <span class="keyword">int</span> stackId)</span> </span>{  
        <span class="keyword">int</span> numDisplays = mActivityDisplays.size();  
        <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = <span class="number">0</span>; displayNdx &lt; numDisplays; ++displayNdx) {  
            ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;  
            <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) {  
                ActivityStack stack = stacks.get(stackNdx);  
                TaskRecord task = stack.taskForIdLocked(id);  
                <span class="keyword">if</span> (task != <span class="keyword">null</span>) {  
                    <span class="keyword">return</span> task;  
                }  
            }  
        }  

        <span class="comment">// Don't give up! Look in recents.//如果任务栈中没有，尝试在RecentTasks中搜索  </span>
        <span class="keyword">if</span> (DEBUG_RECENTS) Slog.v(TAG_RECENTS, <span class="string">"Looking for task id="</span> + id + <span class="string">" in recents"</span>);  
        TaskRecord task = mRecentTasks.taskForIdLocked(id);  
        <span class="keyword">if</span> (task == <span class="keyword">null</span>) {  
            <span class="keyword">if</span> (DEBUG_RECENTS) Slog.d(TAG_RECENTS, <span class="string">"\tDidn't find task id="</span> + id + <span class="string">" in recents"</span>);  
            <span class="keyword">return</span> <span class="keyword">null</span>;  
        }  

        <span class="keyword">if</span> (!restoreFromRecents) {  
            <span class="keyword">return</span> task;  
        }  

        <span class="keyword">if</span> (!restoreRecentTaskLocked(task, stackId)) {  
            <span class="keyword">if</span> (DEBUG_RECENTS) Slog.w(TAG_RECENTS,  
                    <span class="string">"Couldn't restore task id="</span> + id + <span class="string">" found in recents"</span>);  
            <span class="keyword">return</span> <span class="keyword">null</span>;  
        }  
        <span class="keyword">if</span> (DEBUG_RECENTS) Slog.w(TAG_RECENTS, <span class="string">"Restored task id="</span> + id + <span class="string">" from in recents"</span>);  
        <span class="keyword">return</span> task;  
    }  </code></pre>
<p>由于<code>多任务</code>中显示的是最近任务列表，对用户来说，更是所谓在后台运行的应用，正常情况通过taskid是一定能找到一个可重用的taskrecord的。在anyTaskForIdLocked()中，首先遍历任务栈寻找相同taskid应用，如果找不到则在RecentTasks中继续找，找到后通过restoreRecentTaskLocked将taskRecord重新加入合适的ActivityStack中去。这样，本已被销毁的应用从<code>RecentTasks</code>中被加回<code>任务栈</code>，taskId等信息都不变。<br>与上面相对的，直接通过intent方式启动activity时，虽然也会尽可能寻找可重用的task，但却只是从<code>任务栈</code>中遍历寻找intent相同的Task，不会从<code>RecentTasks</code>中再寻找一边。<br>可以说，一个taskRecord实例的唯一标识是taskId，而一个应用task的唯一标识是intent。  </p>
<hr>
<p><strong>注</strong>:</p>
<p>  [3]: <a href="https://developer.android.com/guide/components/recents.html" target="_blank" rel="noopener">https://developer.android.com/guide/components/recents.html</a><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">如果应用历史记录数超过设定的MAX值(48)，会将RecentTasks表末的记录删掉，详见AMS#addAppTask(). L10731<br></p>
<p>[^reboot_restore]:重启后persistent的应用taskRecord会在RecentTasks中重新生成。<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="BenZ"
      src="https://benzgallery.oss-cn-shanghai.aliyuncs.com/sailing_cat 1200.png">
  <p class="site-author-name" itemprop="name">BenZ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/BenZstory" title="GitHub → https://github.com/BenZstory" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhengbin0320@gmail.com" title="E-Mail → mailto:zhengbin0320@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://t.me/sailingcat" title="Telegram → https://t.me/sailingcat" rel="noopener" target="_blank"><i class="fa fa-paper-plane fa-fw"></i>Telegram</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BenZ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://benzbloghexo.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
